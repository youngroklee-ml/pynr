[["index.html", "Python &amp; R Chapter 1 Overview 1.1 Python 1.2 R", " Python &amp; R 이영록 2022-06-10 Chapter 1 Overview 이 책은 Python과 R의 비슷한 점과 차이점을 예제를 통해 알아보기 위한 책이다. 어느 하나가 다른 하나의 우위에 있음을 보이려는 의도가 아니며, Python 사용자가 R을 이해하거나 R 사용자가 Python을 이해하는 데 도움을 주기 위해 작성되었다. 특정 용도(통계 분석, 시각화, 머신 러닝 등)보다는 일반적인 프로그래밍 언어 관점에서 살펴보고자 한다. 따라서 가능한 한 기본 Python 및 R의 내에서 비교하며, R의 경우에는 필요에 따라 R을 좀 더 프로그래밍 언어적으로 사용하기 위한 패키지(rlang 등)를 필요에 따라 추가로 사용할 예정이다. 책 작성 시 사용된 Python과 R의 버전은 다음과 같다. 1.1 Python import sys print(sys.version) ## 3.8.9 (default, Apr 13 2022, 08:48:07) ## [Clang 13.1.6 (clang-1316.0.21.2.5)] 1.2 R R.version$version.string ## [1] &quot;R version 4.1.3 (2022-03-10)&quot; "],["dictionary-named-list-environment.html", "Chapter 2 Dictionary, named list, environment 2.1 Dictionary in Python 2.2 Named list vs environment in R", " Chapter 2 Dictionary, named list, environment 다음과 같은 조건을 충족하기 위한 자료 구조를 생각해 보자. 자료는 여러 원소(element)를 지닌다. 각 원소는 키(key)–혹은 이름(name)–와 값(value)의 쌍으로 이루어진다. 각 원소의 값은 서로 다른 형태(type)일 수 있다. 파이썬에서 이 조건들을 동시에 충족하는 대표적인 자료 구조는 dictionary이다. Tuple과 list는 조건 2를 충족하지 못한다. R의 경우에는 list(보다 구체적으로 named list)와 environment가 세 조건을 모두 충족한다. 그렇다면, named list와 environment 중 어떤 것이 파이썬의 dictionary와 더 비슷할까? 필자는 environment가 더 비슷하다고 생각한다. 다음은 R의 environment만 지닌 파이썬의 dictionary과의 공통점이다. Hash를 사용하여 원소를 빨리 lookup할 수 있다. 원소 이름이 unique해야 한다. Reference semantics를 지닌다(modify-in-place를 지원한다). Position을 사용한 인덱싱이 지원되지 않는다. 여러 원소를 한번에 읽을 수 없다. 반면, R의 list만 파이썬의 dictionary와 지닌 공통점은 다음과 같다. 원소가 생성된 순서가 보존된다. 여기에서 어떠한 공통점이 중요한지에 따라 파이썬의 dictionary와 대응하여 사용하기에 더 적합한 R의 자료 구조를 선택해야 할 것이다. 본 장에서는 아래와 같은 문제 상황에서 environment가 더 적합한 자료 구조임을 보일 것이다. 원소가 생성된 순서는 의미가 없다. 얼마나 많은 원소가 생성될 지 미리 알 수 없으며, 중간에 원소가 삭제될 수도 있는데, 이 때 처리 속도가 빨라야 한다. 각 원소는 자주 읽히기 때문에, 자료를 찾는 속도가 빨라야 한다. 참고로, 파이썬의 dictionary가 R의 environment나 list보다 유연한 부분이 있다. 파이썬의 dictionary에서 key는 어떠한 immutable 객체라도 사용할 수 있는 반면, R의 environment와 named list는 모두 문자열만을 name으로 사용할 수 있다. 2.1 Dictionary in Python 2.1.1 생성 전체 원소 갯수가 미리 정해지지 않은 경우에는 새로운 원소가 들어올 때마다 하나씩 원소를 추가해야 한다. 다음처럼 for loop를 사용하여 원소를 순차적으로 추가하는 시뮬레이션 함수를 만들자. 이 때, key 값을 “item1”, “item2”, … 와 같이 지정하자. def gen_dict(n): ret = {} for x in range(1, n + 1): ret[f&#39;item{x}&#39;] = x return ret py_dict = gen_dict(10000) 결과를 출력할 때, 원소가 입력된 순서가 보존되어 출력된다. [x for x in py_dict.__iter__()][:10] ## [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] 2.1.2 Lookup Key가 “item100”인 원소의 값을 다음과 같이 얻을 수 있다. py_dict[&#39;item100&#39;] ## 100 Dictionary의 경우 position을 사용할 수 없다. py_dict[99] ## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 99 또한, dictionary의 경우 여러 key를 사용하여 한꺼번에 여러 원소의 값을 읽을 수 없다. py_dict[[&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;]] ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; 2.1.3 Reference semantics 두 개의 객체 이름이 같은 dictionary 객체에 binding되었다면, 하나의 객체 이름을 이용하여 특정 원소의 값을 변경하였을 때, reference semantics에 의해 다른 하나의 객체 이름을 이용한 참조 시에도 변경된 값이 나타난다. id(py_dict) ## 4640782528 new_dict = py_dict new_dict[&#39;item100&#39;] = 0 id(new_dict) ## 4640782528 py_dict[&#39;item100&#39;] ## 0 2.2 Named list vs environment in R 위의 파이썬 예를 R에서 named list와 environment 두 가지를 이용해서 각각 구현해 보고, 결과 및 수행 시간을 비교해 보자. 2.2.1 생성 우선 named list를 생성해 보자. 아래 함수가 리스트 길이 n을 인자로 받기 때문에, 빈 리스트를 만든 뒤에 원소를 하나씩 추가하는 코드가 비효율적으로 보일 것이다. 하지만, 여기에서 시뮬레이션을 하려는 상황이 우리가 미리 얼마나 많은 원소가 언제 어떤 이름과 값으로 생성될 지 모르는 상황이라는 점을 기억하자. 따라서, 아래 함수는 단지 비어있는 리스트로 시작하여 원소를 하나씩 추가해야만 하는 경우 수행 시간이 얼마나 걸릴지를 시뮬레이션하기 위한 코드이다. gen_list &lt;- function(n) { ret &lt;- list() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_list &lt;- gen_list(10000)) ## user system elapsed ## 0.784 0.075 0.861 gen_env &lt;- function(n) { ret &lt;- new.env() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_env &lt;- gen_env(10000)) ## user system elapsed ## 0.030 0.001 0.031 이 결과에서, list에 원소를 하나씩 새로 추가하는 것(즉, 길이가 하나씩 증가하는 것)에 비해, environment에 원소를 하나씩 새로 추가하는 시간이 훨씬 짧게 소요되는 것을 확인할 수 있다. 그 차이는 원소의 갯수가 많을수록 더 커진다. 다음 코드는 원소가 입력된 순서가 보존되는지 확인하기 위한 코드이다. names(r_list)[1:10] ## [1] &quot;item1&quot; &quot;item2&quot; &quot;item3&quot; &quot;item4&quot; &quot;item5&quot; &quot;item6&quot; &quot;item7&quot; &quot;item8&quot; &quot;item9&quot; &quot;item10&quot; names(r_env)[1:10] ## [1] &quot;item7082&quot; &quot;item7083&quot; &quot;item7084&quot; &quot;item7085&quot; &quot;item7086&quot; &quot;item5320&quot; &quot;item7087&quot; &quot;item5321&quot; ## [9] &quot;item7088&quot; &quot;item5322&quot; 이 결과에서, list는 순서가 보존되지만, environment는 그렇지 않음을 볼 수 있다. 따라서, 원소 입력 순서를 아는 것이 중요하지 않은 경우에만 environment를 사용하는 것이 적합할 것이다. 2.2.2 Lookup Named list와 environment 모두 원소의 이름을 사용하여 원소의 값을 읽어올 수 있다. r_list[[&quot;item100&quot;]] ## [1] 100 r_env[[&quot;item100&quot;]] ## [1] 100 하지만 그 수행 시간은 사뭇 다르다. 다음 벤치마크를 보자. bench::mark( r_list[[&quot;item100&quot;]], r_env[[&quot;item100&quot;]] ) ## # A tibble: 2 × 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 r_list[[&quot;item100&quot;]] 916ns 1.04µs 932023. 0B 0 ## 2 r_env[[&quot;item100&quot;]] 125ns 209ns 5039202. 0B 0 수행 시간의 median값을 볼 때, 이 예에서 environment가 list보다 몇 배 더 빠르다는 것을 확인할 수 있다. Environment는 파이썬의 dictionary와 마찬가지로 position을 사용하거나 여러 원소 이름을 동시에 사용하여 원소값을 읽을 수 없다. r_env[[100]] ## Error in r_env[[100]]: wrong arguments for subsetting an environment r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## Error in r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)]: object of type &#39;environment&#39; is not subsettable 하지만 list는 이것이 가능하다. r_list[[100]] ## [1] 100 r_list[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## $item1 ## [1] 1 ## ## $item2 ## [1] 2 ## ## $item3 ## [1] 3 2.2.3 Reference semantics Environment는 reference semantics을 지녀 modify-in-place 방식으로 작동한다. pryr::address(r_env) ## [1] &quot;0x7f893b4f1508&quot; new_env &lt;- r_env new_env[[&#39;item100&#39;]] = 0 pryr::address(new_env) ## [1] &quot;0x7f893b4f1508&quot; r_env[[&#39;item100&#39;]] ## [1] 0 반면, list는 copy-on-modify 방식으로 작동한다. pryr::address(r_list) ## [1] &quot;0x7f89817c8000&quot; new_list &lt;- r_list new_list[[&#39;item100&#39;]] = 0 pryr::address(new_list) ## [1] &quot;0x7f8950a08000&quot; r_list[[&#39;item100&#39;]] ## [1] 100 2.2.4 Uniqueness R의 named list는 name의 중복을 허용한다. names(new_list) &lt;- rep(&quot;item100&quot;, length(new_list)) head(new_list) ## $item100 ## [1] 1 ## ## $item100 ## [1] 2 ## ## $item100 ## [1] 3 ## ## $item100 ## [1] 4 ## ## $item100 ## [1] 5 ## ## $item100 ## [1] 6 이 경우, 원소의 이름을 사용하여 원소를 찾는 과정이 모호해진다. 원소 이름이 일치하는 첫 번째 원소만을 반환할 것이다. new_list[[&quot;item100&quot;]] ## [1] 1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
