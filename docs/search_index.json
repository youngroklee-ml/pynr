[["index.html", "Python &amp; R Chapter 1 Overview 1.1 Python 1.2 R", " Python &amp; R 이영록 2022-06-14 Chapter 1 Overview 이 책은 Python과 R의 비슷한 점과 차이점을 예제를 통해 알아보기 위한 책이다. 어느 하나가 다른 하나의 우위에 있음을 보이려는 의도가 아니며, Python 사용자가 R을 이해하거나 R 사용자가 Python을 이해하는 데 도움을 주기 위해 작성되었다. 특정 용도(통계 분석, 시각화, 머신 러닝 등)보다는 일반적인 프로그래밍 언어 관점에서 살펴보고자 한다. 따라서 가능한 한 기본 Python 및 R의 내에서 비교하며, R의 경우에는 필요에 따라 R을 좀 더 프로그래밍 언어적으로 사용하기 위한 패키지(rlang 등)를 필요에 따라 추가로 사용할 예정이다. 책 작성 시 사용된 Python과 R의 버전은 다음과 같다. 1.1 Python import sys print(sys.version) ## 3.8.9 (default, Apr 13 2022, 08:48:07) ## [Clang 13.1.6 (clang-1316.0.21.2.5)] 1.2 R R.version$version.string ## [1] &quot;R version 4.1.3 (2022-03-10)&quot; "],["dictionary-named-list-environment.html", "Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 2.1 Dictionary in Python 2.2 Named list vs environment in R", " Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 다음과 같은 조건을 충족하기 위한 자료 구조를 생각해 보자. 자료는 여러 원소(element)를 지닌다. 각 원소는 키(key)–혹은 이름(name)–와 값(value)의 쌍으로 이루어진다. 각 원소의 값은 서로 다른 형태(type)일 수 있다. 파이썬에서 이 조건들을 동시에 충족하는 대표적인 자료 구조는 dictionary이다. Tuple과 list는 조건 2를 충족하지 못한다. R의 경우에는 list(보다 구체적으로 named list)와 environment가 세 조건을 모두 충족한다. 그렇다면, named list와 environment 중 어떤 것이 파이썬의 dictionary와 더 비슷할까? 필자는 environment가 더 비슷하다고 생각한다. 다음은 R의 environment만 지닌 파이썬의 dictionary과의 공통점이다. Hash를 사용하여 원소를 빨리 lookup할 수 있다. 원소 이름이 unique해야 한다. Reference semantics를 지닌다(modify-in-place를 지원한다). Position을 사용한 인덱싱이 지원되지 않는다. 여러 원소를 한번에 읽을 수 없다. 반면, R의 list만 파이썬의 dictionary와 지닌 공통점은 다음과 같다. 원소가 생성된 순서가 보존된다. 여기에서 어떠한 공통점이 중요한지에 따라 파이썬의 dictionary와 대응하여 사용하기에 더 적합한 R의 자료 구조를 선택해야 할 것이다. 본 장에서는 아래와 같은 문제 상황에서 environment가 더 적합한 자료 구조임을 보일 것이다. 원소가 생성된 순서는 의미가 없다. 얼마나 많은 원소가 생성될 지 미리 알 수 없으며, 중간에 원소가 삭제될 수도 있는데, 이 때 처리 속도가 빨라야 한다. 각 원소는 자주 읽히기 때문에, 자료를 찾는 속도가 빨라야 한다. 참고로, 파이썬의 dictionary가 R의 environment나 list보다 유연한 부분이 있다. 파이썬의 dictionary에서 key는 어떠한 immutable 객체라도 사용할 수 있는 반면, R의 environment와 named list는 모두 문자열만을 name으로 사용할 수 있다. 2.1 Dictionary in Python 2.1.1 생성 전체 원소 갯수가 미리 정해지지 않은 경우에는 새로운 원소가 들어올 때마다 하나씩 원소를 추가해야 한다. 다음처럼 for loop를 사용하여 원소를 순차적으로 추가하는 시뮬레이션 함수를 만들자. 이 때, key 값을 “item1”, “item2”, … 와 같이 지정하자. def gen_dict(n): ret = {} for x in range(1, n + 1): ret[f&#39;item{x}&#39;] = x return ret py_dict = gen_dict(10000) 결과를 출력할 때, 원소가 입력된 순서가 보존되어 출력된다. list(py_dict.__iter__())[:10] ## [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] 2.1.2 Lookup Key가 “item100”인 원소의 값을 다음과 같이 얻을 수 있다. py_dict[&#39;item100&#39;] ## 100 Dictionary의 경우 position을 사용할 수 없다. py_dict[99] ## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 99 또한, dictionary의 경우 여러 key를 사용하여 한꺼번에 여러 원소의 값을 읽을 수 없다. py_dict[[&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;]] ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; 2.1.3 Reference semantics 두 개의 객체 이름이 같은 dictionary 객체에 binding되었다면, 하나의 객체 이름을 이용하여 특정 원소의 값을 변경하였을 때, reference semantics에 의해 다른 하나의 객체 이름을 이용한 참조 시에도 변경된 값이 나타난다. id(py_dict) ## 4518894912 new_dict = py_dict new_dict[&#39;item100&#39;] = 0 id(new_dict) ## 4518894912 py_dict[&#39;item100&#39;] ## 0 2.2 Named list vs environment in R 위의 파이썬 예를 R에서 named list와 environment 두 가지를 이용해서 각각 구현해 보고, 결과 및 수행 시간을 비교해 보자. 2.2.1 생성 우선 named list를 생성해 보자. 아래 함수가 리스트 길이 n을 인자로 받기 때문에, 빈 리스트를 만든 뒤에 원소를 하나씩 추가하는 코드가 비효율적으로 보일 것이다. 하지만, 여기에서 시뮬레이션을 하려는 상황이 우리가 미리 얼마나 많은 원소가 언제 어떤 이름과 값으로 생성될 지 모르는 상황이라는 점을 기억하자. 따라서, 아래 함수는 단지 비어있는 리스트로 시작하여 원소를 하나씩 추가해야만 하는 경우 수행 시간이 얼마나 걸릴지를 시뮬레이션하기 위한 코드이다. gen_list &lt;- function(n) { ret &lt;- list() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_list &lt;- gen_list(10000)) ## user system elapsed ## 0.730 0.026 0.757 gen_env &lt;- function(n) { ret &lt;- new.env() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_env &lt;- gen_env(10000)) ## user system elapsed ## 0.03 0.00 0.03 이 결과에서, list에 원소를 하나씩 새로 추가하는 것(즉, 길이가 하나씩 증가하는 것)에 비해, environment에 원소를 하나씩 새로 추가하는 시간이 훨씬 짧게 소요되는 것을 확인할 수 있다. 그 차이는 원소의 갯수가 많을수록 더 커진다. 다음 코드는 원소가 입력된 순서가 보존되는지 확인하기 위한 코드이다. names(r_list)[1:10] ## [1] &quot;item1&quot; &quot;item2&quot; &quot;item3&quot; &quot;item4&quot; &quot;item5&quot; &quot;item6&quot; &quot;item7&quot; &quot;item8&quot; ## [9] &quot;item9&quot; &quot;item10&quot; names(r_env)[1:10] ## [1] &quot;item7082&quot; &quot;item7083&quot; &quot;item7084&quot; &quot;item7085&quot; &quot;item7086&quot; &quot;item5320&quot; ## [7] &quot;item7087&quot; &quot;item5321&quot; &quot;item7088&quot; &quot;item5322&quot; 이 결과에서, list는 순서가 보존되지만, environment는 그렇지 않음을 볼 수 있다. 따라서, 원소 입력 순서를 아는 것이 중요하지 않은 경우에만 environment를 사용하는 것이 적합할 것이다. 2.2.2 Lookup Named list와 environment 모두 원소의 이름을 사용하여 원소의 값을 읽어올 수 있다. r_list[[&quot;item100&quot;]] ## [1] 100 r_env[[&quot;item100&quot;]] ## [1] 100 하지만 그 수행 시간은 사뭇 다르다. 다음 벤치마크를 보자. bench::mark( r_list[[&quot;item100&quot;]], r_env[[&quot;item100&quot;]], time_unit = &quot;ns&quot; ) ## # A tibble: 2 × 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 r_list[[&quot;item100&quot;]] 917. 1000. 954943. 0B 0 ## 2 r_env[[&quot;item100&quot;]] 83.0 125. 6963701. 0B 0 수행 시간의 median값을 볼 때, 이 예에서 environment가 list보다 몇 배 더 빠르다는 것을 확인할 수 있다. Environment는 파이썬의 dictionary와 마찬가지로 position을 사용하거나 여러 원소 이름을 동시에 사용하여 원소값을 읽을 수 없다. r_env[[100]] ## Error in r_env[[100]]: wrong arguments for subsetting an environment r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## Error in r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)]: object of type &#39;environment&#39; is not subsettable 하지만 list는 이것이 가능하다. r_list[[100]] ## [1] 100 r_list[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## $item1 ## [1] 1 ## ## $item2 ## [1] 2 ## ## $item3 ## [1] 3 2.2.3 Reference semantics Environment는 reference semantics을 지녀 modify-in-place 방식으로 작동한다. pryr::address(r_env) ## [1] &quot;0x7ff69cb06958&quot; new_env &lt;- r_env new_env[[&#39;item100&#39;]] &lt;- 0 pryr::address(new_env) ## [1] &quot;0x7ff69cb06958&quot; r_env[[&#39;item100&#39;]] ## [1] 0 반면, list는 copy-on-modify 방식으로 작동한다. pryr::address(r_list) ## [1] &quot;0x7ff6b3920000&quot; new_list &lt;- r_list new_list[[&#39;item100&#39;]] &lt;- 0 pryr::address(new_list) ## [1] &quot;0x7ff690648000&quot; r_list[[&#39;item100&#39;]] ## [1] 100 2.2.4 Uniqueness R의 named list는 name의 중복을 허용한다. names(new_list) &lt;- rep(&quot;item100&quot;, length(new_list)) head(new_list) ## $item100 ## [1] 1 ## ## $item100 ## [1] 2 ## ## $item100 ## [1] 3 ## ## $item100 ## [1] 4 ## ## $item100 ## [1] 5 ## ## $item100 ## [1] 6 이 경우, 원소의 이름을 사용하여 원소를 찾는 과정이 모호해진다. 원소 이름이 일치하는 첫 번째 원소만을 반환할 것이다. new_list[[&quot;item100&quot;]] ## [1] 1 "],["tuple-list-list.html", "Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 3.1 Tuple vs list in Python 3.2 List in R", " Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 파이썬에 내장된 대표적인 시퀀스(sequence)형 자료 형태로 tuple(튜플, 투플, 터플)과 list(리스트)를 들 수 있다. 두 자료 형태 모두 위치(position)를 사용하여 원소를 읽을 수 있으며, 각 원소가 서로 다른 타입일 수 있다. 예를 들어, 첫 번째 원소는 숫자, 두 번째 원소는 문자열 등으로 구성될 수 있다. Tuple은 흔히 immutable list로 설명되기도 하는데, 일반적으로 그 원소의 값을 modify-in-place로 변경할 수 없기 때문이다. 반면 list는 mutable object로, 기존에 만들어진 list 내에서 원소의 값을 변경하는 것이 가능하다. 보다 자세한 내용은 아래에서 살펴보기로 하자. 기존에 존재하는 원소의 변경 여부 외에, 새로운 원소를 추가할 수 있는지, 즉 기존 n개의 원소를 지닌 시퀀스에 n + 1번째 원소를 추가할 수 있는지에 대한 차이도 존재한다. Tuple의 경우 길이가 고정된 시퀀스로써 새로운 원소를 추가할 수 없지만, list의 경우에는 기존 list에 원소를 추가한다던가 기존 원소를 제거하는 등 시퀀스의 길이를 변경하게 되는 작업을 수행할 수 있다. 하지만 이것이 list가 mutable 객체라고 주장하는 근거가 되기에는 약간 한계가 있는 부분이 있는데, 이는 본문에서 예와 함께 설명하기로 한다. 필자는 이 두 가지 파이썬 자료 형태 중 list가 R의 list와 공통점이 더 많다고 생각한다. 가장 중요한 공통점은 mutable 객체라는 점이다. 즉, 파이썬의 list와 R의 list 모두 modify-in-place를 지원한다. 단, 이 때 R의 경우 single binding을 가정하자. 보다 자세한 내용은 본문에서 다루기로 하자. 3.1 Tuple vs list in Python 파이썬에서 tuple과 list의 차이를 간단한 예를 통해 살펴보자. 3.1.1 Immutable vs mutable 숫자 1부터 10까지를 각 원소로 지니는 길이 10짜리 tuple과 list를 생성해 보자. py_tuple = tuple(range(1, 11)) py_tuple ## (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) py_list = list(range(1, 11)) py_list ## [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이후, py_tuple의 첫 번째 원소의 값을 변경하려 시도한다면, 오류를 얻게 된다. 이는 tuple이 한 번 생성된 후에는 원소의 값을 변경할 수 없는 immutable 객체이기 때문이다. py_tuple[0] = 0 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;tuple&#39; object does not support item assignment 반면, list의 경우에는 첫 번째 원소(뿐만 아니라 어느 위치의 원소이든)의 값을 변경할 수 있다. 이 때, 내부적으로 새로운 list를 생성하는 것이 아니라, 기존 list의 원소값만 변경하게 된다. 이를 확인하기 위해 원소값 변경 전과 후의 py_list의 메모리 위치를 id(py_list)로 출력해 보자. py_list[0] ## 1 id(py_list) ## 4555607744 py_list[0] = 0 py_list[0] ## 0 id(py_list) ## 4555607744 위 결과와 같이, 원소의 값을 변경하더라도 list 객체의 메모리 위치는 변함이 없는 modify-in-place 방식을 지원한다. 3.1.1.1 Mutable element of tuple 여기에서 tuple의 immutability를 얘기할 때 조심해야 할 부분이 있다. 만약 tuple의 어떤 원소가 list와 같은 mutable 객체라면, 이 mutable 원소의 원소값을 수정할 수 있다. 다음 예에서, tuple a의 두 번째 원소인 list의 첫 번째 원소를 변경할 수 있다. a = (0, [1, 2]) a ## (0, [1, 2]) a[1][0] = 0 a ## (0, [0, 2]) 이는 tuple이 원소의 값 자체가 아니라, 원소의 값이 저장된 위치를 참조하는 reference를 지니기 때문이다. Tuple의 각 원소의 값이 저장된 위치를 변경할 수는 없지만, 그 원소가 mutable 객체라면 그 원소의 값 자체를 변경할 수는 있는 것이다. 이 부분은 본 장에서 핵심적인 부분은 아니기 때문에 여기까지만 설명하기로 하자. 3.1.2 Append items 시퀀스에 새로운 11번째 원소를 추가하고 싶다고 생각해 보자. Tuple의 경우 길이가 정해진 시퀀스이기 때문에 새로운 원소를 이후에 추가할 수가 없다. 만약 꼭 추가해야 한다면, 새로운 tuple을 생성하는 방법 밖에는 없다. 이 경우, 새로운 tuple이 생성되었음을 id() 함수를 통해 확인할 수 있다. id(py_tuple) ## 4554628800 py_tuple = py_tuple + (11, ) py_tuple[10] ## 11 id(py_tuple) ## 4554802880 반면, list의 경우 append()를 사용하여 기존의 list에 원소를 추가할 수 있다. id(py_list) ## 4555607744 py_list.append(11) py_list[10] ## 11 id(py_list) ## 4555607744 이 예에서 py_list의 메모리 주소는 변하지 않았다. 이는 마치 list가 mutable 객체이기 때문인 것으로 보이지만, 필자는 이는 절반만 맞는 설명이라 하겠다. 실제로는, 파이썬은 list를 생성할 때, 이후에 추가될 수 있는 원소를 위한 공간을 미리 어느 정도 남겨둔다. 따라서, 그 남겨둔 공간까지는 원소를 추가하더라도 list에 할당된 메모리 공간이 변하지 않지만, 그 범위를 넘어서는 순간 list에 메모리 공간이 재할당된다. 이 재할당 작업을 너무 자주 수행하지 않기 위해 미리 당장 필요하지 않은 메모리를 확보해 두는 것이다. 다음 예는 list의 메모리 공간이 매 원소 추가 시마다 증가하는 것이 아니라 이따금 한 번에 증가한다는 것을 보여준다. print(sys.getsizeof(py_list)) ## 200 for x in range(12, 31): py_list.append(x) print(f&#39;Number of elements: {len(py_list)}, memory size: {sys.getsizeof(py_list)}&#39;) ## Number of elements: 12, memory size: 200 ## Number of elements: 13, memory size: 200 ## Number of elements: 14, memory size: 200 ## Number of elements: 15, memory size: 200 ## Number of elements: 16, memory size: 200 ## Number of elements: 17, memory size: 200 ## Number of elements: 18, memory size: 200 ## Number of elements: 19, memory size: 272 ## Number of elements: 20, memory size: 272 ## Number of elements: 21, memory size: 272 ## Number of elements: 22, memory size: 272 ## Number of elements: 23, memory size: 272 ## Number of elements: 24, memory size: 272 ## Number of elements: 25, memory size: 272 ## Number of elements: 26, memory size: 272 ## Number of elements: 27, memory size: 272 ## Number of elements: 28, memory size: 352 ## Number of elements: 29, memory size: 352 ## Number of elements: 30, memory size: 352 주의: sys.getsizeof()는 리스트의 각 원소가 참조하는 값에 할당된 메모리를 포함하지 않고, 단지 리스트 자체(각 원소의 주소값을 저장하는 시퀀스)에 할당된 메모리 크기만 나타낸다. 이 예에서 py_list의 메모리 주소는 이전의 메모리 주소와 여전히 동일하다. id(py_list) ## 4555607744 3.2 List in R R에 내장된 대표적인 시퀀스(sequence)형 자료 형태로는 vector와 list가 있는데, 이 중 파이썬의 tuple이나 list와 같이 각 원소의 형태가 다른 시퀀스를 제공하는 R의 시퀀스는 list이다. 위 파이썬의 예와 마찬가지로, 1에서 10까지의 원소값을 지니는 길이 10의 list를 생성해 보자. r_list &lt;- as.list(1:10) print(r_list) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 ## ## [[10]] ## [1] 10 3.2.1 Mutable object 이 list가 저장된 메모리 주소를 pryr::address()로 출력해 보자. 또한, 동일한 list 객체가 또 다른 이름으로 참조되고 있지 않은지를 보기 위해 pryr::refs()를 함께 호출해 보자. 이 값이 1인 경우(single binding)에는 modify-in-place 방식이 작동하여 원소값 변경 전/후의 list의 메모리 주소가 변경되지 않지만, 2 이상인 경우에는 copy-on-modify 방식이 작동하여 원소값 변경 시 list가 항상 다른 곳에 복사된 뒤 값이 변경된다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefb7e46c28&quot; &quot;3&quot; 이후, 첫 번째 원소의 값을 변경하려 시도해 보자. 이 때, 만약 앞에서 pryr::refs(r_list)의 값이 1보다 큰 수였다면, 메모리 주소가 변경될 것이다. r_list[[1]] &lt;- 0L r_list[[1]] ## [1] 0 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefc468cf78&quot; &quot;1&quot; 앞의 결과에서 원소값 변경 이후 pryr::refs(r_list)의 값이 1이었다면, 다시금 첫 번째 원소의 값(혹은 어떤 원소의 값이든)을 변경할 때 r_list의 메모리 주소는 동일하게 유지될 것이다. r_list[[1]] &lt;- 1L r_list[[1]] ## [1] 1 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefc468cf78&quot; &quot;1&quot; 이는 R의 list가 파이썬의 list처럼 modify-in-place를 지원하는 mutable object라는 것을 보여준다. 주의: RStudio IDE의 인터랙티브 환경에서 수행할 때는 아마도 copy-on-modify 방식이 작동할 수 있는데, 이는 RStudio IDE 내에서 해당 list 객체를 추가로 참조하여 pryr::refs() 값이 항상 1보다 크기 때문일 것이다. 따라서, modify-in-place는 인터랙티브 환경이 아닐 때 더 잘 확인할 수 있을 것이다. 3.2.2 Append items 먼저, r_list의 내부 구조를 살펴보기 위해 pryr::inspect()를 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7fefc468cf78&gt; ## &lt;INTSXP 0x7fefb7bad0c8&gt; ## &lt;INTSXP 0x7fefc3d37c48&gt; ## &lt;INTSXP 0x7fefc3d37c10&gt; ## &lt;INTSXP 0x7fefc3d37bd8&gt; ## &lt;INTSXP 0x7fefc3d37ba0&gt; ## &lt;INTSXP 0x7fefc3d37b68&gt; ## &lt;INTSXP 0x7fefc3d37b30&gt; ## &lt;INTSXP 0x7fefc3d37af8&gt; ## &lt;INTSXP 0x7fefc3d37ac0&gt; ## &lt;INTSXP 0x7fefc3d37a88&gt; 이 결과는 r_list가 VECSXP라는 형태(list)의 C 객체이며, 그 각 원소는 INTSXP라는 형태(integer vector)의 C 객체임을 보여주고, VECSXP 객체와 각 INTSXP 객체가 저장된 메모리 주소를 보여준다. 파이썬의 list에서 새로운 원소를 추가하기 위해 append() method를 사용했던 것과 달리, R의 list에서는 기존 원소를 변경하는 것과 동일한 방법으로 새로운 원소를 추가할 수 있다. r_list[[11]] &lt;- 11L r_list[[11]] ## [1] 11 단, 이 때는 modify-in-place가 아닌 copy-on-modify 방식이 작동한다는 것을 인지하자. 다음에서 메모리 주소가 이전과 변경되었음을 확인할 수 있을 것이다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefb79290d8&quot; &quot;1&quot; 좀 더 자세히 살펴보기 위해 pryr::inspect()를 다시 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7fefb79290d8&gt; ## &lt;INTSXP 0x7fefb7bad0c8&gt; ## &lt;INTSXP 0x7fefc3d37c48&gt; ## &lt;INTSXP 0x7fefc3d37c10&gt; ## &lt;INTSXP 0x7fefc3d37bd8&gt; ## &lt;INTSXP 0x7fefc3d37ba0&gt; ## &lt;INTSXP 0x7fefc3d37b68&gt; ## &lt;INTSXP 0x7fefc3d37b30&gt; ## &lt;INTSXP 0x7fefc3d37af8&gt; ## &lt;INTSXP 0x7fefc3d37ac0&gt; ## &lt;INTSXP 0x7fefc3d37a88&gt; ## &lt;INTSXP 0x7fefc33a6c38&gt; VECSXP 객체의 메모리 주소는 변경된 반면, 하나의 추가된 INTSXP 객체를 제외하면, 기존에 있던 INTSXP 객체의 메모리 주소는 여전히 동일함을 보여준다. 그리고, pryr::address(r_list)가 보여주는 주소값은 VECSXP 객체의 주소값임을 보여준다. 원소를 계속 하나씩 추가하면서, list 메모리 위치가 어떻게 바뀌는지 살펴보자. for (x in 12:30) { r_list[[x]] &lt;- x print( glue::glue( &quot;Number of elements: {length(r_list)}&quot;, &quot;memory address: {pryr::address(r_list)}&quot;, .sep = &quot;, &quot; ) ) } ## Number of elements: 12, memory address: 0x7fefc4685778 ## Number of elements: 13, memory address: 0x7fefc462a1e8 ## Number of elements: 14, memory address: 0x7fefc462a088 ## Number of elements: 15, memory address: 0x7fefc4629f28 ## Number of elements: 16, memory address: 0x7fefc4629dc8 ## Number of elements: 17, memory address: 0x6000022e8540 ## Number of elements: 18, memory address: 0x6000022f89c0 ## Number of elements: 19, memory address: 0x600002c9fb50 ## Number of elements: 20, memory address: 0x600002e81a40 ## Number of elements: 21, memory address: 0x600002e81a40 ## Number of elements: 22, memory address: 0x600002891860 ## Number of elements: 23, memory address: 0x600002891860 ## Number of elements: 24, memory address: 0x600002b84100 ## Number of elements: 25, memory address: 0x600002b84100 ## Number of elements: 26, memory address: 0x7fefb4fe26c0 ## Number of elements: 27, memory address: 0x7fefb4fe26c0 ## Number of elements: 28, memory address: 0x7fefb4f253f0 ## Number of elements: 29, memory address: 0x7fefb4f253f0 ## Number of elements: 30, memory address: 0x7fefb4fe2ad0 R list의 경우, 원소 개수가 하나씩 증가할 때마다 메모리 주소가 변경됨을 확인할 수 있을 것이다. 즉, list의 길이가 변경될 때마다 매번 새로 list를 위한 메모리가 재할당되기 때문에 python의 list보다 컴퓨팅 리소스가 좀 더 소모되며, 그 정도는 list의 길이가 길수록 증가할 것이다. 다만, 앞에서 살펴본 바와 같이 VECSXP 객체의 메모리는 재할당되는 반면, 각 원소값이 저장된 메모리는 그대로 유지되어 참조되므로, 추가적인 컴퓨팅은 제한적이라 하겠다. "],["array-vector.html", "Chapter 4 파이썬의 array, 그리고 R의 vector 4.1 파이썬의 array 4.2 R의 vector", " Chapter 4 파이썬의 array, 그리고 R의 vector 모든 원소가 동일한 형태인 시퀀스 자료 구조를 생각해 보자. 파이썬에서 tuple이나 list는 각 원소의 형태가 다름을 허용하지만, array(보다 정확하게는 array.array)는 모든 원소의 형태가 동일해야 한다. 이 때, 원소의 형태는 C에서 제공하는 기본 형태인 정수, 실수, 문자 등이다. 파이썬의 array는 mutable 객체로, modify-in-place를 지원한다. 필자는 파이썬의 array와 가장 흡사한 R의 자료 구조는 vector(atomic vector)라고 생각한다. R의 vector에서도 모든 원소가 하나의 자료 형태여야 한다. 이 때, 원소의 대표적인 자료 형태는 R에서 기본적으로 제공하는 logical, 정수, 실수, 문자열 등이다. R의 vector는 R의 list와 마찬가지 이유로 mutable 객체라 할 수 있다. 하지만, 파이썬의 array와 R의 vector 간에는 몇 가지 중요한 차이점도 존재한다. 예를 들어, 현재 시퀀스의 원소 형태와 다른 원소값을 입력하려 하는 경우, 파이썬의 array는 오류를 반환하는 반면, R은 자동으로 type coercion을 수행한다. 원소가 문자 형태인 경우, 파이썬의 array는 원소 당 하나의 문자만 지닐 수 있는 반면, R의 vector는 문자열을 원소로 지닐 수 있다. 다음에서 예시를 통해 보다 자세히 살펴보기로 하자. 4.1 파이썬의 array 파이썬의 array는 파이썬의 standard library에 속한 array 모듈을 사용하여 생성한다. from array import array py_array = array(&#39;l&#39;, range(1, 11)) py_array ## array(&#39;l&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 4.1.1 Mutability 이 때, 원소의 값을 수정하더라도 array의 메모리 주소가 변하지 않음을 확인하자. id(py_array) ## 4516916592 py_array[0] = 0 id(py_array) ## 4516916592 4.1.2 다른 타입의 원소 입력하기 앞에서 py_array는 정수('l') 형태의 원소를 지닌 array로 생성하였다. 여기에 정수가 아닌 원소를 입력하려 하면 어떻게 될까? 실험을 위해 첫 번째 원소에 실수('f') 형태의 값인 1.0을 입력하려 시도하면 오류가 발생할 것이다. py_array[0] = 1.0 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: integer argument expected, got float 4.1.3 원소 추가하기 파이썬의 list와 마찬가지로, 파이썬의 array 또한 필요보다 많은 메모리를 미리 할당하여, 원소가 추가될 때마다 매번 메모리 할당에 컴퓨팅을 소요하지 않도록 하였다. print(sys.getsizeof(py_array)) ## 192 for x in range(11, 31): py_array.append(x) print(f&#39;Number of elements: {len(py_array)}, memory size: {sys.getsizeof(py_array)}&#39;) ## Number of elements: 11, memory size: 192 ## Number of elements: 12, memory size: 192 ## Number of elements: 13, memory size: 192 ## Number of elements: 14, memory size: 192 ## Number of elements: 15, memory size: 192 ## Number of elements: 16, memory size: 192 ## Number of elements: 17, memory size: 264 ## Number of elements: 18, memory size: 264 ## Number of elements: 19, memory size: 264 ## Number of elements: 20, memory size: 264 ## Number of elements: 21, memory size: 264 ## Number of elements: 22, memory size: 264 ## Number of elements: 23, memory size: 264 ## Number of elements: 24, memory size: 264 ## Number of elements: 25, memory size: 264 ## Number of elements: 26, memory size: 336 ## Number of elements: 27, memory size: 336 ## Number of elements: 28, memory size: 336 ## Number of elements: 29, memory size: 336 ## Number of elements: 30, memory size: 336 앞의 예에서, 원소들이 추가된 이후에도 py_array의 메모리 주소는 변하지 않는다. id(py_array) ## 4516916592 4.1.4 문자열 시퀀스 파이썬에서 각 원소가 하나의 문자를 지닌 array는 다음과 같이 생성할 수 있다. array(&#39;u&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) ## array(&#39;u&#39;, &#39;abc&#39;) 하지만, 각 원소가 문자열인 array는 생성할 수 없다. array(&#39;u&#39;, [&#39;abc&#39;, &#39;def&#39;]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: array item must be unicode character 4.2 R의 vector R에서 atomic vector는 흔히 c() 함수를 사용하여 생성하지만, 여기에서는 보다 명시적으로 데이터 타입을 보여주기 위해서 as.vector()를 사용하자. r_vector &lt;- as.vector(1:10, mode = &quot;integer&quot;) typeof(r_vector) ## [1] &quot;integer&quot; print(r_vector) ## [1] 1 2 3 4 5 6 7 8 9 10 pryr::inspect()를 통해 vector의 메모리 구조를 살펴보자. pryr::inspect(r_vector) ## &lt;INTSXP 0x7fe7c2c4d008&gt; List와는 달리, vector에서는 각 원소가 다른 메모리 영역을 참조하는 것이 아니라 실제 원소값을 지니기 때문에, 각 원소값에 해당하는 메모리 주소가 따로 출력되지 않는 것을 볼 수 있다. 4.2.1 Mutability 이 vector가 저장된 메모리 주소를 pryr::address()로 출력해 보자. 또한, 동일한 vector 객체가 또 다른 이름으로 참조되고 있지 않은지를 보기 위해 pryr::refs()를 함께 호출해 보자. 이 값이 1인 경우(single binding)에는 modify-in-place 방식이 작동하여 원소값 변경 시 vector의 메모리 주소가 변경되지 않지만, 2 이상인 경우에는 copy-on-modify 방식이 작동하여 vector가 다른 곳에 복사된 뒤 값이 변경된다. c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fe7c2c4d008&quot; &quot;65535&quot; 이후, 첫 번째 원소의 값을 변경하려 시도해 보자. 이 때, 만약 앞에서 pryr::refs(r_vector)의 값이 1보다 큰 수였다면, 메모리 주소가 변경될 것이다. r_vector[[1]] &lt;- 0L r_vector[[1]] ## [1] 0 c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fe7c40c7198&quot; &quot;1&quot; 앞의 결과에서 원소값 변경 이후 pryr::refs(r_vector)의 값이 1이었다면, 다시금 첫 번째 원소의 값(혹은 어떤 원소의 값이든)을 변경할 때 r_vector의 메모리 주소는 동일하게 유지될 것이다. r_vector[[1]] &lt;- 1L r_vector[[1]] ## [1] 1 c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fe7c40c7198&quot; &quot;1&quot; 이는 R의 vector 또한 modify-in-place를 지원하는 mutable object라는 것을 보여준다. 주의: RStudio IDE 상에서 원소값을 변경할 때는 list와 마찬가지로 추가적으로 발생하는 참조로 인해 pryr::refs() 값이 항상 1보다 클 수 있기 때문에, mutability는 인터랙티브 개발 환경으로부터 독립된 프로세스에서 더 잘 확인할 수 있을 것이다. 4.2.2 다른 타입의 원소 입력하기 앞서 파이썬의 경우와는 달리, R의 vector는 현재 지정된 형태와 다른 원소가 입력되었을 때 자동으로 type coercion을 수행한다. 예를 들어, 첫 번째 원소의 값으로 정수 1L이 아닌 실수 1.0을 입력할 때, R에서 미리 지정된 type coercion logic에 따라 vector의 모든 원소가 실수(double)로 변경될 것이다. r_vector[[1]] &lt;- 1.0 typeof(r_vector) ## [1] &quot;double&quot; 이 경우에는 vector 전체가 새로운 메모리 주소에 할당될 것이다. c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fe7c2662af8&quot; &quot;1&quot; 또한 pryr::inspect()를 호출하였을 때 C 객체 타입이 앞서 INTSXP에서 REALSXP로 변경되었음을 확인할 수 있다. pryr::inspect(r_vector) ## &lt;REALSXP 0x7fe7c2662af8&gt; 4.2.3 원소 추가하기 R의 list과 마찬가지로, R의 vector는 기존에 존재하지 않는 position에 원소를 추가하는 것처럼 보이게 코드를 작성할 수 있지만, 실제로는 새로운 메모리 주소에 vector를 생성하는 작업이 진행된다. 다음과 같이 원소를 하나씩 추가하며 메모리 주소와 할당된 메모리 크기가 어떻게 바뀌는지 살펴보자. for (x in 11:30) { r_vector[[x]] &lt;- x print( glue::glue( &quot;Number of elements: {length(r_vector)}&quot;, &quot;memory address: {pryr::address(r_vector)}&quot;, &quot;memory size: {pryr::object_size(r_vector)}&quot;, .sep = &quot;, &quot; ) ) } ## Number of elements: 11, memory address: 0x7fe7c3c6f6d8, memory size: 176 ## Number of elements: 12, memory address: 0x7fe7b46bb348, memory size: 176 ## Number of elements: 13, memory address: 0x7fe7b46bb088, memory size: 176 ## Number of elements: 14, memory address: 0x7fe7b46badc8, memory size: 176 ## Number of elements: 15, memory address: 0x7fe7b46bab08, memory size: 176 ## Number of elements: 16, memory address: 0x7fe7b46ba848, memory size: 176 ## Number of elements: 17, memory address: 0x6000028f9680, memory size: 184 ## Number of elements: 18, memory address: 0x6000028f4600, memory size: 192 ## Number of elements: 19, memory address: 0x6000026f0750, memory size: 200 ## Number of elements: 20, memory address: 0x6000024b1ce0, memory size: 208 ## Number of elements: 21, memory address: 0x600002490000, memory size: 216 ## Number of elements: 22, memory address: 0x600002296850, memory size: 224 ## Number of elements: 23, memory address: 0x600002296a30, memory size: 232 ## Number of elements: 24, memory address: 0x6000021b7f00, memory size: 240 ## Number of elements: 25, memory address: 0x6000021bcb00, memory size: 248 ## Number of elements: 26, memory address: 0x7fe7e0f99e60, memory size: 256 ## Number of elements: 27, memory address: 0x7fe7e0f8bb70, memory size: 264 ## Number of elements: 28, memory address: 0x7fe7e0fc9d20, memory size: 272 ## Number of elements: 29, memory address: 0x7fe7e0fc9f50, memory size: 280 ## Number of elements: 30, memory address: 0x7fe7e0fca190, memory size: 288 원소 개수가 하나씩 증가할 때마다 메모리 주소가 변경되며 메모리 크기가 8 byte(double 형태의 데이터의 크기)씩 증가함을 확인할 수 있을 것이다. 매번 메모리 재할당 및 복사 작업으로 인해, R vector의 원소를 추가할 때마다 필요한 작업량이 파이썬의 array를 사용할 때보다 더 많을 것이며, vector의 길이가 길수록 그 차이가 더 커지게 될 것이다. 4.2.4 문자열 시퀀스 R에서는 각 원소가 문자열인 vector를 각 원소가 하나의 문자인 vector를 생성할 때와 마찬가지 방식으로 생성할 수 있다. r_char_vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) typeof(r_char_vec) ## [1] &quot;character&quot; r_char_vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; r_str_vec &lt;- c(&quot;abc&quot;, &quot;def&quot;) typeof(r_str_vec) ## [1] &quot;character&quot; r_str_vec ## [1] &quot;abc&quot; &quot;def&quot; typeof() 결과에서 보이듯이, 두 가지 경우 모두 R에서는 “character” 형태의 원소를 지닌 vector로 인식한다. 다시 말해, R에서는 문자열의 길이와 상관이 없이 문자형의 데이터를 “character” 형태라고 한다. 이 두 객체에 대해 pryr::inspect()를 호출하면, list에서와 같이 각 원소에 해당하는 메모리 주소가 출력되는 것을 볼 수 있다. 이는 각 원소에 실제 원소값을 저장한 다른 vector와는 달리, 문자열 vector는 list와 마찬가지로 각 원소에 실제 원소값에 대한 주소값을 지니며, 다만 list와는 달리 그 원소값의 형태가 문자열(C에서는 CHARSXP 객체)로 제한된다는 점을 의미한다고 하겠다. pryr::inspect(r_char_vec) ## &lt;STRSXP 0x7fe7b57f35d8&gt; ## &lt;CHARSXP 0x7fe7e1971b48&gt; ## &lt;CHARSXP 0x7fe7e11f38e8&gt; ## &lt;CHARSXP 0x7fe7e100e0c0&gt; pryr::inspect(r_str_vec) ## &lt;STRSXP 0x7fe7c3a9e1c8&gt; ## &lt;CHARSXP 0x7fe7b27a1940&gt; ## &lt;CHARSXP 0x7fe7e14a9ea8&gt; 문자열에 대해서는 추후 기회가 되면 별도로 다시 다루기로 하자. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
