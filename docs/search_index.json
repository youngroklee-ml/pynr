[["index.html", "Python &amp; R Chapter 1 Overview 1.1 Python 1.2 R", " Python &amp; R 이영록 2022-07-04 Chapter 1 Overview 이 책은 Python과 R의 비슷한 점과 차이점을 예제를 통해 알아보기 위한 책이다. 어느 하나가 다른 하나의 우위에 있음을 보이려는 의도가 아니며, Python 사용자가 R을 이해하거나 R 사용자가 Python을 이해하는 데 도움을 주기 위해 작성되었다. 특정 용도(통계 분석, 시각화, 머신 러닝 등)보다는 일반적인 프로그래밍 언어 관점에서 살펴보고자 한다. 따라서 가능한 한 기본 Python 및 R의 내에서 비교하며, R의 경우에는 필요에 따라 R을 좀 더 프로그래밍 언어적으로 사용하기 위한 패키지(rlang 등)를 필요에 따라 추가로 사용할 예정이다. 책 작성 시 사용된 Python과 R의 버전은 다음과 같다. 1.1 Python import sys print(sys.version) ## 3.8.9 (default, Apr 13 2022, 08:48:07) ## [Clang 13.1.6 (clang-1316.0.21.2.5)] 1.2 R R.version$version.string ## [1] &quot;R version 4.1.3 (2022-03-10)&quot; "],["dictionary-named-list-environment.html", "Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 2.1 Dictionary in Python 2.2 Named list vs environment in R", " Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 다음과 같은 조건을 충족하기 위한 자료 구조를 생각해 보자. 자료는 여러 원소(element)를 지닌다. 각 원소는 키(key)–혹은 이름(name)–와 값(value)의 쌍으로 이루어진다. 각 원소의 값은 서로 다른 형태(type)일 수 있다. 파이썬에서 이 조건들을 동시에 충족하는 대표적인 자료 구조는 dictionary이다. Tuple과 list는 조건 2를 충족하지 못한다. R의 경우에는 list(보다 구체적으로 named list)와 environment가 세 조건을 모두 충족한다. 그렇다면, named list와 environment 중 어떤 것이 파이썬의 dictionary와 더 비슷할까? 필자는 environment가 더 비슷하다고 생각한다. 다음은 R의 environment만 지닌 파이썬의 dictionary과의 공통점이다. Hash를 사용하여 원소를 빨리 lookup할 수 있다. 원소 이름이 unique해야 한다. Reference semantics를 지닌다(modify-in-place를 지원한다). Position을 사용한 인덱싱이 지원되지 않는다. 여러 원소를 한번에 읽을 수 없다. 반면, R의 list만 파이썬의 dictionary와 지닌 공통점은 다음과 같다. 원소가 생성된 순서가 보존된다. 여기에서 어떠한 공통점이 중요한지에 따라 파이썬의 dictionary와 대응하여 사용하기에 더 적합한 R의 자료 구조를 선택해야 할 것이다. 본 장에서는 아래와 같은 문제 상황에서 environment가 더 적합한 자료 구조임을 보일 것이다. 원소가 생성된 순서는 의미가 없다. 얼마나 많은 원소가 생성될 지 미리 알 수 없으며, 중간에 원소가 삭제될 수도 있는데, 이 때 처리 속도가 빨라야 한다. 각 원소는 자주 읽히기 때문에, 자료를 찾는 속도가 빨라야 한다. 참고로, 파이썬의 dictionary가 R의 environment나 list보다 유연한 부분이 있다. 파이썬의 dictionary에서 key는 어떠한 immutable 객체라도 사용할 수 있는 반면, R의 environment와 named list는 모두 문자열만을 name으로 사용할 수 있다. 2.1 Dictionary in Python 2.1.1 생성 전체 원소 갯수가 미리 정해지지 않은 경우에는 새로운 원소가 들어올 때마다 하나씩 원소를 추가해야 한다. 다음처럼 for loop를 사용하여 원소를 순차적으로 추가하는 시뮬레이션 함수를 만들자. 이 때, key 값을 “item1”, “item2”, … 와 같이 지정하자. def gen_dict(n): ret = {} for x in range(1, n + 1): ret[f&#39;item{x}&#39;] = x return ret py_dict = gen_dict(10000) 결과를 출력할 때, 원소가 입력된 순서가 보존되어 출력된다. list(py_dict.__iter__())[:10] ## [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] 2.1.2 Lookup Key가 “item100”인 원소의 값을 다음과 같이 얻을 수 있다. py_dict[&#39;item100&#39;] ## 100 Dictionary의 경우 position을 사용할 수 없다. py_dict[99] ## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 99 또한, dictionary의 경우 여러 key를 사용하여 한꺼번에 여러 원소의 값을 읽을 수 없다. py_dict[[&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;]] ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; 2.1.3 Reference semantics 두 개의 객체 이름이 같은 dictionary 객체에 binding되었다면, 하나의 객체 이름을 이용하여 특정 원소의 값을 변경하였을 때, reference semantics에 의해 다른 하나의 객체 이름을 이용한 참조 시에도 변경된 값이 나타난다. id(py_dict) ## 4674297600 new_dict = py_dict new_dict[&#39;item100&#39;] = 0 id(new_dict) ## 4674297600 py_dict[&#39;item100&#39;] ## 0 2.2 Named list vs environment in R 위의 파이썬 예를 R에서 named list와 environment 두 가지를 이용해서 각각 구현해 보고, 결과 및 수행 시간을 비교해 보자. 2.2.1 생성 우선 named list를 생성해 보자. 아래 함수가 리스트 길이 n을 인자로 받기 때문에, 빈 리스트를 만든 뒤에 원소를 하나씩 추가하는 코드가 비효율적으로 보일 것이다. 하지만, 여기에서 시뮬레이션을 하려는 상황이 우리가 미리 얼마나 많은 원소가 언제 어떤 이름과 값으로 생성될 지 모르는 상황이라는 점을 기억하자. 따라서, 아래 함수는 단지 비어있는 리스트로 시작하여 원소를 하나씩 추가해야만 하는 경우 수행 시간이 얼마나 걸릴지를 시뮬레이션하기 위한 코드이다. gen_list &lt;- function(n) { ret &lt;- list() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_list &lt;- gen_list(10000)) ## user system elapsed ## 0.778 0.034 0.814 gen_env &lt;- function(n) { ret &lt;- new.env() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_env &lt;- gen_env(10000)) ## user system elapsed ## 0.031 0.000 0.032 이 결과에서, list에 원소를 하나씩 새로 추가하는 것(즉, 길이가 하나씩 증가하는 것)에 비해, environment에 원소를 하나씩 새로 추가하는 시간이 훨씬 짧게 소요되는 것을 확인할 수 있다. 그 차이는 원소의 갯수가 많을수록 더 커진다. 다음 코드는 원소가 입력된 순서가 보존되는지 확인하기 위한 코드이다. names(r_list)[1:10] ## [1] &quot;item1&quot; &quot;item2&quot; &quot;item3&quot; &quot;item4&quot; &quot;item5&quot; &quot;item6&quot; &quot;item7&quot; &quot;item8&quot; ## [9] &quot;item9&quot; &quot;item10&quot; names(r_env)[1:10] ## [1] &quot;item7082&quot; &quot;item7083&quot; &quot;item7084&quot; &quot;item7085&quot; &quot;item7086&quot; &quot;item5320&quot; ## [7] &quot;item7087&quot; &quot;item5321&quot; &quot;item7088&quot; &quot;item5322&quot; 이 결과에서, list는 순서가 보존되지만, environment는 그렇지 않음을 볼 수 있다. 따라서, 원소 입력 순서를 아는 것이 중요하지 않은 경우에만 environment를 사용하는 것이 적합할 것이다. 2.2.2 Lookup Named list와 environment 모두 원소의 이름을 사용하여 원소의 값을 읽어올 수 있다. r_list[[&quot;item100&quot;]] ## [1] 100 r_env[[&quot;item100&quot;]] ## [1] 100 하지만 그 수행 시간은 사뭇 다르다. 다음 벤치마크를 보자. bench::mark( r_list[[&quot;item100&quot;]], r_env[[&quot;item100&quot;]], time_unit = &quot;ns&quot; ) ## # A tibble: 2 × 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 r_list[[&quot;item100&quot;]] 917. 1042. 944104. 0B 0 ## 2 r_env[[&quot;item100&quot;]] 1 125. 8881893. 0B 0 수행 시간의 median값을 볼 때, 이 예에서 environment가 list보다 몇 배 더 빠르다는 것을 확인할 수 있다. Environment는 파이썬의 dictionary와 마찬가지로 position을 사용하거나 여러 원소 이름을 동시에 사용하여 원소값을 읽을 수 없다. r_env[[100]] ## Error in r_env[[100]]: wrong arguments for subsetting an environment r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## Error in r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)]: object of type &#39;environment&#39; is not subsettable 하지만 list는 이것이 가능하다. r_list[[100]] ## [1] 100 r_list[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## $item1 ## [1] 1 ## ## $item2 ## [1] 2 ## ## $item3 ## [1] 3 2.2.3 Reference semantics Environment는 reference semantics을 지녀 modify-in-place 방식으로 작동한다. pryr::address(r_env) ## [1] &quot;0x7fe6ffe27b90&quot; new_env &lt;- r_env new_env[[&#39;item100&#39;]] &lt;- 0 pryr::address(new_env) ## [1] &quot;0x7fe6ffe27b90&quot; r_env[[&#39;item100&#39;]] ## [1] 0 반면, list는 copy-on-modify 방식으로 작동한다. pryr::address(r_list) ## [1] &quot;0x7fe7112d0000&quot; new_list &lt;- r_list new_list[[&#39;item100&#39;]] &lt;- 0 pryr::address(new_list) ## [1] &quot;0x7fe7115f8000&quot; r_list[[&#39;item100&#39;]] ## [1] 100 2.2.4 Uniqueness R의 named list는 name의 중복을 허용한다. names(new_list) &lt;- rep(&quot;item100&quot;, length(new_list)) head(new_list) ## $item100 ## [1] 1 ## ## $item100 ## [1] 2 ## ## $item100 ## [1] 3 ## ## $item100 ## [1] 4 ## ## $item100 ## [1] 5 ## ## $item100 ## [1] 6 이 경우, 원소의 이름을 사용하여 원소를 찾는 과정이 모호해진다. 원소 이름이 일치하는 첫 번째 원소만을 반환할 것이다. new_list[[&quot;item100&quot;]] ## [1] 1 "],["tuple-list-list.html", "Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 3.1 Tuple vs list in Python 3.2 List in R", " Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 파이썬에 내장된 대표적인 시퀀스(sequence)형 자료 형태로 tuple(튜플, 투플, 터플)과 list(리스트)를 들 수 있다. 두 자료 형태 모두 위치(position)를 사용하여 원소를 읽을 수 있으며, 각 원소가 서로 다른 타입일 수 있다. 예를 들어, 첫 번째 원소는 숫자, 두 번째 원소는 문자열 등으로 구성될 수 있다. Tuple은 흔히 immutable list로 설명되기도 하는데, 일반적으로 그 원소의 값을 modify-in-place로 변경할 수 없기 때문이다. 반면 list는 mutable object로, 기존에 만들어진 list 내에서 원소의 값을 변경하는 것이 가능하다. 보다 자세한 내용은 아래에서 살펴보기로 하자. 기존에 존재하는 원소의 변경 여부 외에, 새로운 원소를 추가할 수 있는지, 즉 기존 n개의 원소를 지닌 시퀀스에 n + 1번째 원소를 추가할 수 있는지에 대한 차이도 존재한다. Tuple의 경우 길이가 고정된 시퀀스로써 새로운 원소를 추가할 수 없지만, list의 경우에는 기존 list에 원소를 추가한다던가 기존 원소를 제거하는 등 시퀀스의 길이를 변경하게 되는 작업을 수행할 수 있다. 하지만 이것이 list가 mutable 객체라고 주장하는 근거가 되기에는 약간 한계가 있는 부분이 있는데, 이는 본문에서 예와 함께 설명하기로 한다. 필자는 이 두 가지 파이썬 자료 형태 중 list가 R의 list와 공통점이 더 많다고 생각한다. 가장 중요한 공통점은 mutable 객체라는 점이다. 즉, 파이썬의 list와 R의 list 모두 modify-in-place를 지원한다. 단, 이 때 R의 경우 single binding을 가정하자. 보다 자세한 내용은 본문에서 다루기로 하자. 3.1 Tuple vs list in Python 파이썬에서 tuple과 list의 차이를 간단한 예를 통해 살펴보자. 3.1.1 Immutable vs mutable 숫자 1부터 10까지를 각 원소로 지니는 길이 10짜리 tuple과 list를 생성해 보자. py_tuple = tuple(range(1, 11)) py_tuple ## (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) py_list = list(range(1, 11)) py_list ## [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이후, py_tuple의 첫 번째 원소의 값을 변경하려 시도한다면, 오류를 얻게 된다. 이는 tuple이 한 번 생성된 후에는 원소의 값을 변경할 수 없는 immutable 객체이기 때문이다. py_tuple[0] = 0 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;tuple&#39; object does not support item assignment 반면, list의 경우에는 첫 번째 원소(뿐만 아니라 어느 위치의 원소이든)의 값을 변경할 수 있다. 이 때, 내부적으로 새로운 list를 생성하는 것이 아니라, 기존 list의 원소값만 변경하게 된다. 이를 확인하기 위해 원소값 변경 전과 후의 py_list의 메모리 위치를 id(py_list)로 출력해 보자. py_list[0] ## 1 id(py_list) ## 4634284416 py_list[0] = 0 py_list[0] ## 0 id(py_list) ## 4634284416 위 결과와 같이, 원소의 값을 변경하더라도 list 객체의 메모리 위치는 변함이 없는 modify-in-place 방식을 지원한다. 3.1.1.1 Mutable element of tuple 여기에서 tuple의 immutability를 얘기할 때 조심해야 할 부분이 있다. 만약 tuple의 어떤 원소가 list와 같은 mutable 객체라면, 이 mutable 원소의 원소값을 수정할 수 있다. 다음 예에서, tuple a의 두 번째 원소인 list의 첫 번째 원소를 변경할 수 있다. a = (0, [1, 2]) a ## (0, [1, 2]) a[1][0] = 0 a ## (0, [0, 2]) 이는 tuple이 원소의 값 자체가 아니라, 원소의 값이 저장된 위치를 참조하는 reference를 지니기 때문이다. Tuple의 각 원소의 값이 저장된 위치를 변경할 수는 없지만, 그 원소가 mutable 객체라면 그 원소의 값 자체를 변경할 수는 있는 것이다. 이 부분은 본 장에서 핵심적인 부분은 아니기 때문에 여기까지만 설명하기로 하자. 3.1.2 Append items 시퀀스에 새로운 11번째 원소를 추가하고 싶다고 생각해 보자. Tuple의 경우 길이가 정해진 시퀀스이기 때문에 새로운 원소를 이후에 추가할 수가 없다. 만약 꼭 추가해야 한다면, 새로운 tuple을 생성하는 방법 밖에는 없다. 이 경우, 새로운 tuple이 생성되었음을 id() 함수를 통해 확인할 수 있다. id(py_tuple) ## 4627644864 py_tuple = py_tuple + (11, ) py_tuple[10] ## 11 id(py_tuple) ## 4632183744 반면, list의 경우 append()를 사용하여 기존의 list에 원소를 추가할 수 있다. id(py_list) ## 4634284416 py_list.append(11) py_list[10] ## 11 id(py_list) ## 4634284416 이 예에서 py_list의 메모리 주소는 변하지 않았다. 이는 마치 list가 mutable 객체이기 때문인 것으로 보이지만, 필자는 이는 절반만 맞는 설명이라 하겠다. 실제로는, 파이썬은 list를 생성할 때, 이후에 추가될 수 있는 원소를 위한 공간을 미리 어느 정도 남겨둔다. 따라서, 그 남겨둔 공간까지는 원소를 추가하더라도 list에 할당된 메모리 공간이 변하지 않지만, 그 범위를 넘어서는 순간 list에 메모리 공간이 재할당된다. 이 재할당 작업을 너무 자주 수행하지 않기 위해 미리 당장 필요하지 않은 메모리를 확보해 두는 것이다. 다음 예는 list의 메모리 공간이 매 원소 추가 시마다 증가하는 것이 아니라 이따금 한 번에 증가한다는 것을 보여준다. print(sys.getsizeof(py_list)) ## 200 for x in range(12, 31): py_list.append(x) print(f&#39;Number of elements: {len(py_list)}, memory size: {sys.getsizeof(py_list)}&#39;) ## Number of elements: 12, memory size: 200 ## Number of elements: 13, memory size: 200 ## Number of elements: 14, memory size: 200 ## Number of elements: 15, memory size: 200 ## Number of elements: 16, memory size: 200 ## Number of elements: 17, memory size: 200 ## Number of elements: 18, memory size: 200 ## Number of elements: 19, memory size: 272 ## Number of elements: 20, memory size: 272 ## Number of elements: 21, memory size: 272 ## Number of elements: 22, memory size: 272 ## Number of elements: 23, memory size: 272 ## Number of elements: 24, memory size: 272 ## Number of elements: 25, memory size: 272 ## Number of elements: 26, memory size: 272 ## Number of elements: 27, memory size: 272 ## Number of elements: 28, memory size: 352 ## Number of elements: 29, memory size: 352 ## Number of elements: 30, memory size: 352 주의: sys.getsizeof()는 리스트의 각 원소가 참조하는 값에 할당된 메모리를 포함하지 않고, 단지 리스트 자체(각 원소의 주소값을 저장하는 시퀀스)에 할당된 메모리 크기만 나타낸다. 이 예에서 py_list의 메모리 주소는 이전의 메모리 주소와 여전히 동일하다. id(py_list) ## 4634284416 3.2 List in R R에 내장된 대표적인 시퀀스(sequence)형 자료 형태로는 vector와 list가 있는데, 이 중 파이썬의 tuple이나 list와 같이 각 원소의 형태가 다른 시퀀스를 제공하는 R의 시퀀스는 list이다. 위 파이썬의 예와 마찬가지로, 1에서 10까지의 원소값을 지니는 길이 10의 list를 생성해 보자. r_list &lt;- as.list(1:10) print(r_list) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 ## ## [[10]] ## [1] 10 3.2.1 Mutable object 이 list가 저장된 메모리 주소를 pryr::address()로 출력해 보자. 또한, 동일한 list 객체가 또 다른 이름으로 참조되고 있지 않은지를 보기 위해 pryr::refs()를 함께 호출해 보자. 이 값이 1인 경우(single binding)에는 modify-in-place 방식이 작동하여 원소값 변경 전/후의 list의 메모리 주소가 변경되지 않지만, 2 이상인 경우에는 copy-on-modify 방식이 작동하여 원소값 변경 시 list가 항상 다른 곳에 복사된 뒤 값이 변경된다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefbe67a218&quot; &quot;3&quot; 이후, 첫 번째 원소의 값을 변경하려 시도해 보자. 이 때, 만약 앞에서 pryr::refs(r_list)의 값이 1보다 큰 수였다면, 메모리 주소가 변경될 것이다. r_list[[1]] &lt;- 0L r_list[[1]] ## [1] 0 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefac87ca98&quot; &quot;1&quot; 앞의 결과에서 원소값 변경 이후 pryr::refs(r_list)의 값이 1이었다면, 다시금 첫 번째 원소의 값(혹은 어떤 원소의 값이든)을 변경할 때 r_list의 메모리 주소는 동일하게 유지될 것이다. r_list[[1]] &lt;- 1L r_list[[1]] ## [1] 1 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefac87ca98&quot; &quot;1&quot; 이는 R의 list가 파이썬의 list처럼 modify-in-place를 지원하는 mutable object라는 것을 보여준다. 주의: RStudio IDE의 인터랙티브 환경에서 수행할 때는 아마도 copy-on-modify 방식이 작동할 수 있는데, 이는 RStudio IDE 내에서 해당 list 객체를 추가로 참조하여 pryr::refs() 값이 항상 1보다 크기 때문일 것이다. 따라서, modify-in-place는 인터랙티브 환경이 아닐 때 더 잘 확인할 수 있을 것이다. 3.2.2 Append items 먼저, r_list의 내부 구조를 살펴보기 위해 pryr::inspect()를 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7fefac87ca98&gt; ## &lt;INTSXP 0x7fefbe293a70&gt; ## &lt;INTSXP 0x7fefbe7bb990&gt; ## &lt;INTSXP 0x7fefbe7bb958&gt; ## &lt;INTSXP 0x7fefbe7bb920&gt; ## &lt;INTSXP 0x7fefbe7bb8e8&gt; ## &lt;INTSXP 0x7fefbe7bb878&gt; ## &lt;INTSXP 0x7fefbe7bb808&gt; ## &lt;INTSXP 0x7fefbe7bb7d0&gt; ## &lt;INTSXP 0x7fefbe7bb760&gt; ## &lt;INTSXP 0x7fefbe7bb728&gt; 이 결과는 r_list가 VECSXP라는 형태(list)의 C 객체이며, 그 각 원소는 INTSXP라는 형태(integer vector)의 C 객체임을 보여주고, VECSXP 객체와 각 INTSXP 객체가 저장된 메모리 주소를 보여준다. 파이썬의 list에서 새로운 원소를 추가하기 위해 append() method를 사용했던 것과 달리, R의 list에서는 기존 원소를 변경하는 것과 동일한 방법으로 새로운 원소를 추가할 수 있다. r_list[[11]] &lt;- 11L r_list[[11]] ## [1] 11 단, 이 때는 modify-in-place가 아닌 copy-on-modify 방식이 작동한다는 것을 인지하자. 다음에서 메모리 주소가 이전과 변경되었음을 확인할 수 있을 것이다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7fefaf4c1808&quot; &quot;1&quot; 좀 더 자세히 살펴보기 위해 pryr::inspect()를 다시 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7fefaf4c1808&gt; ## &lt;INTSXP 0x7fefbe293a70&gt; ## &lt;INTSXP 0x7fefbe7bb990&gt; ## &lt;INTSXP 0x7fefbe7bb958&gt; ## &lt;INTSXP 0x7fefbe7bb920&gt; ## &lt;INTSXP 0x7fefbe7bb8e8&gt; ## &lt;INTSXP 0x7fefbe7bb878&gt; ## &lt;INTSXP 0x7fefbe7bb808&gt; ## &lt;INTSXP 0x7fefbe7bb7d0&gt; ## &lt;INTSXP 0x7fefbe7bb760&gt; ## &lt;INTSXP 0x7fefbe7bb728&gt; ## &lt;INTSXP 0x7fefad469648&gt; VECSXP 객체의 메모리 주소는 변경된 반면, 하나의 추가된 INTSXP 객체를 제외하면, 기존에 있던 INTSXP 객체의 메모리 주소는 여전히 동일함을 보여준다. 그리고, pryr::address(r_list)가 보여주는 주소값은 VECSXP 객체의 주소값임을 보여준다. 원소를 계속 하나씩 추가하면서, list 메모리 위치가 어떻게 바뀌는지 살펴보자. for (x in 12:30) { r_list[[x]] &lt;- x print( glue::glue( &quot;Number of elements: {length(r_list)}&quot;, &quot;memory address: {pryr::address(r_list)}&quot;, .sep = &quot;, &quot; ) ) } ## Number of elements: 12, memory address: 0x7fefbe687c18 ## Number of elements: 13, memory address: 0x7fefad5fbae8 ## Number of elements: 14, memory address: 0x7fefad5fb988 ## Number of elements: 15, memory address: 0x7fefad5fb828 ## Number of elements: 16, memory address: 0x7fefad5fb6c8 ## Number of elements: 17, memory address: 0x600002cfd980 ## Number of elements: 18, memory address: 0x600002cfda40 ## Number of elements: 19, memory address: 0x600002282b10 ## Number of elements: 20, memory address: 0x60000209ff00 ## Number of elements: 21, memory address: 0x60000209ff00 ## Number of elements: 22, memory address: 0x60000269dc20 ## Number of elements: 23, memory address: 0x60000269dc20 ## Number of elements: 24, memory address: 0x6000025a5300 ## Number of elements: 25, memory address: 0x6000025a5300 ## Number of elements: 26, memory address: 0x7fef9bf24400 ## Number of elements: 27, memory address: 0x7fef9bf24400 ## Number of elements: 28, memory address: 0x7fef9bf24510 ## Number of elements: 29, memory address: 0x7fef9bf24510 ## Number of elements: 30, memory address: 0x7fef9bf24630 R list의 경우, 원소 개수가 하나씩 증가할 때마다 메모리 주소가 변경됨을 확인할 수 있을 것이다. 즉, list의 길이가 변경될 때마다 매번 새로 list를 위한 메모리가 재할당되기 때문에 python의 list보다 컴퓨팅 리소스가 좀 더 소모되며, 그 정도는 list의 길이가 길수록 증가할 것이다. 다만, 앞에서 살펴본 바와 같이 VECSXP 객체의 메모리는 재할당되는 반면, 각 원소값이 저장된 메모리는 그대로 유지되어 참조되므로, 추가적인 컴퓨팅은 제한적이라 하겠다. "],["array-vector.html", "Chapter 4 파이썬의 array, 그리고 R의 vector 4.1 파이썬의 array 4.2 R의 vector 4.3 파이썬 NumPy", " Chapter 4 파이썬의 array, 그리고 R의 vector 모든 원소가 동일한 형태인 시퀀스 자료 구조를 생각해 보자. 파이썬에서 tuple이나 list는 각 원소의 형태가 다름을 허용하지만, array(보다 정확하게는 array.array)는 모든 원소의 형태가 동일해야 한다. 이 때, 원소의 형태는 C에서 제공하는 기본 형태인 정수, 실수, 문자 등이다. 파이썬의 array는 mutable 객체로, modify-in-place를 지원한다. 필자는 파이썬의 array와 가장 흡사한 R의 자료 구조는 vector(atomic vector)라고 생각한다. R의 vector에서도 모든 원소가 하나의 자료 형태여야 한다. 이 때, 원소의 대표적인 자료 형태는 R에서 기본적으로 제공하는 logical, 정수, 실수, 문자열 등이다. R의 vector는 R의 list와 마찬가지 이유로 mutable 객체라 할 수 있다. 하지만, 파이썬의 array와 R의 vector 간에는 몇 가지 중요한 차이점도 존재한다. 예를 들어, 현재 시퀀스의 원소 형태와 다른 원소값을 입력하려 하는 경우, 파이썬의 array는 오류를 반환하는 반면, R은 자동으로 type coercion을 수행한다. 원소가 문자 형태인 경우, 파이썬의 array는 원소 당 하나의 문자만 지닐 수 있는 반면, R의 vector는 문자열을 원소로 지닐 수 있다. 다음에서 예시를 통해 보다 자세히 살펴보기로 하자. 4.1 파이썬의 array 파이썬의 array는 파이썬의 standard library에 속한 array 모듈을 사용하여 생성한다. from array import array py_array = array(&#39;l&#39;, range(1, 11)) py_array ## array(&#39;l&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 4.1.1 Mutability 이 때, 원소의 값을 수정하더라도 array의 메모리 주소가 변하지 않음을 확인하자. id(py_array) ## 4646838448 py_array[0] = 0 id(py_array) ## 4646838448 4.1.2 다른 타입의 원소 입력하기 앞에서 py_array는 정수('l') 형태의 원소를 지닌 array로 생성하였다. 여기에 정수가 아닌 원소를 입력하려 하면 어떻게 될까? 실험을 위해 첫 번째 원소에 실수('f') 형태의 값인 1.0을 입력하려 시도하면 오류가 발생할 것이다. py_array[0] = 1.0 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: integer argument expected, got float 4.1.3 원소 추가하기 파이썬의 list와 마찬가지로, 파이썬의 array 또한 필요보다 많은 메모리를 미리 할당하여, 원소가 추가될 때마다 매번 메모리 할당에 컴퓨팅을 소요하지 않도록 하였다. print(sys.getsizeof(py_array)) ## 192 for x in range(11, 31): py_array.append(x) print(f&#39;Number of elements: {len(py_array)}, memory size: {sys.getsizeof(py_array)}&#39;) ## Number of elements: 11, memory size: 192 ## Number of elements: 12, memory size: 192 ## Number of elements: 13, memory size: 192 ## Number of elements: 14, memory size: 192 ## Number of elements: 15, memory size: 192 ## Number of elements: 16, memory size: 192 ## Number of elements: 17, memory size: 264 ## Number of elements: 18, memory size: 264 ## Number of elements: 19, memory size: 264 ## Number of elements: 20, memory size: 264 ## Number of elements: 21, memory size: 264 ## Number of elements: 22, memory size: 264 ## Number of elements: 23, memory size: 264 ## Number of elements: 24, memory size: 264 ## Number of elements: 25, memory size: 264 ## Number of elements: 26, memory size: 336 ## Number of elements: 27, memory size: 336 ## Number of elements: 28, memory size: 336 ## Number of elements: 29, memory size: 336 ## Number of elements: 30, memory size: 336 앞의 예에서, 원소들이 추가된 이후에도 py_array의 메모리 주소는 변하지 않는다. id(py_array) ## 4646838448 4.1.4 문자열 시퀀스 파이썬에서 각 원소가 하나의 문자를 지닌 array는 다음과 같이 생성할 수 있다. array(&#39;u&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) ## array(&#39;u&#39;, &#39;abc&#39;) 하지만, 각 원소가 문자열인 array는 생성할 수 없다. array(&#39;u&#39;, [&#39;abc&#39;, &#39;def&#39;]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: array item must be unicode character 4.2 R의 vector R에서 atomic vector는 흔히 c() 함수를 사용하여 생성하지만, 여기에서는 보다 명시적으로 데이터 타입을 보여주기 위해서 as.vector()를 사용하자. r_vector &lt;- as.vector(1:10, mode = &quot;integer&quot;) typeof(r_vector) ## [1] &quot;integer&quot; print(r_vector) ## [1] 1 2 3 4 5 6 7 8 9 10 pryr::inspect()를 통해 vector의 메모리 구조를 살펴보자. pryr::inspect(r_vector) ## &lt;INTSXP 0x7fbffe256320&gt; List와는 달리, vector에서는 각 원소가 다른 메모리 영역을 참조하는 것이 아니라 실제 원소값을 지니기 때문에, 각 원소값에 해당하는 메모리 주소가 따로 출력되지 않는 것을 볼 수 있다. 4.2.1 Mutability 이 vector가 저장된 메모리 주소를 pryr::address()로 출력해 보자. 또한, 동일한 vector 객체가 또 다른 이름으로 참조되고 있지 않은지를 보기 위해 pryr::refs()를 함께 호출해 보자. 이 값이 1인 경우(single binding)에는 modify-in-place 방식이 작동하여 원소값 변경 시 vector의 메모리 주소가 변경되지 않지만, 2 이상인 경우에는 copy-on-modify 방식이 작동하여 vector가 다른 곳에 복사된 뒤 값이 변경된다. c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fbffe256320&quot; &quot;65535&quot; 이후, 첫 번째 원소의 값을 변경하려 시도해 보자. 이 때, 만약 앞에서 pryr::refs(r_vector)의 값이 1보다 큰 수였다면, 메모리 주소가 변경될 것이다. r_vector[[1]] &lt;- 0L r_vector[[1]] ## [1] 0 c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fc0093840b8&quot; &quot;1&quot; 앞의 결과에서 원소값 변경 이후 pryr::refs(r_vector)의 값이 1이었다면, 다시금 첫 번째 원소의 값(혹은 어떤 원소의 값이든)을 변경할 때 r_vector의 메모리 주소는 동일하게 유지될 것이다. r_vector[[1]] &lt;- 1L r_vector[[1]] ## [1] 1 c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fc0093840b8&quot; &quot;1&quot; 이는 R의 vector 또한 modify-in-place를 지원하는 mutable object라는 것을 보여준다. 주의: RStudio IDE 상에서 원소값을 변경할 때는 list와 마찬가지로 추가적으로 발생하는 참조로 인해 pryr::refs() 값이 항상 1보다 클 수 있기 때문에, mutability는 인터랙티브 개발 환경으로부터 독립된 프로세스에서 더 잘 확인할 수 있을 것이다. 4.2.2 다른 타입의 원소 입력하기 앞서 파이썬의 경우와는 달리, R의 vector는 현재 지정된 형태와 다른 원소가 입력되었을 때 자동으로 type coercion을 수행한다. 예를 들어, 첫 번째 원소의 값으로 정수 1L이 아닌 실수 1.0을 입력할 때, R에서 미리 지정된 type coercion logic에 따라 vector의 모든 원소가 실수(double)로 변경될 것이다. r_vector[[1]] &lt;- 1.0 typeof(r_vector) ## [1] &quot;double&quot; 이 경우에는 vector 전체가 새로운 메모리 주소에 할당될 것이다. c(pryr::address(r_vector), pryr::refs(r_vector)) ## [1] &quot;0x7fc019674e28&quot; &quot;1&quot; 또한 pryr::inspect()를 호출하였을 때 C 객체 타입이 앞서 INTSXP에서 REALSXP로 변경되었음을 확인할 수 있다. pryr::inspect(r_vector) ## &lt;REALSXP 0x7fc019674e28&gt; 4.2.3 원소 추가하기 R의 list과 마찬가지로, R의 vector는 기존에 존재하지 않는 position에 원소를 추가하는 것처럼 보이게 코드를 작성할 수 있지만, 실제로는 새로운 메모리 주소에 vector를 생성하는 작업이 진행된다. 다음과 같이 원소를 하나씩 추가하며 메모리 주소와 할당된 메모리 크기가 어떻게 바뀌는지 살펴보자. for (x in 11:30) { r_vector[[x]] &lt;- x print( glue::glue( &quot;Number of elements: {length(r_vector)}&quot;, &quot;memory address: {pryr::address(r_vector)}&quot;, &quot;memory size: {pryr::object_size(r_vector)}&quot;, .sep = &quot;, &quot; ) ) } ## Number of elements: 11, memory address: 0x7fbffa9d8008, memory size: 176 ## Number of elements: 12, memory address: 0x7fc01965d778, memory size: 176 ## Number of elements: 13, memory address: 0x7fc01965d148, memory size: 176 ## Number of elements: 14, memory address: 0x7fc01965cdd8, memory size: 176 ## Number of elements: 15, memory address: 0x7fc01965c438, memory size: 176 ## Number of elements: 16, memory address: 0x7fc01965be08, memory size: 176 ## Number of elements: 17, memory address: 0x6000038661c0, memory size: 184 ## Number of elements: 18, memory address: 0x600003866340, memory size: 192 ## Number of elements: 19, memory address: 0x600003669c70, memory size: 200 ## Number of elements: 20, memory address: 0x60000347e920, memory size: 208 ## Number of elements: 21, memory address: 0x60000347e840, memory size: 216 ## Number of elements: 22, memory address: 0x60000327ec10, memory size: 224 ## Number of elements: 23, memory address: 0x60000327edf0, memory size: 232 ## Number of elements: 24, memory address: 0x600003157800, memory size: 240 ## Number of elements: 25, memory address: 0x600003157f00, memory size: 248 ## Number of elements: 26, memory address: 0x7fc02a09f000, memory size: 256 ## Number of elements: 27, memory address: 0x7fc02a09bfc0, memory size: 264 ## Number of elements: 28, memory address: 0x7fc02a09c1e0, memory size: 272 ## Number of elements: 29, memory address: 0x7fc02a09a720, memory size: 280 ## Number of elements: 30, memory address: 0x7fc02a09a960, memory size: 288 원소 개수가 하나씩 증가할 때마다 메모리 주소가 변경되며 메모리 크기가 8 byte(double 형태의 데이터의 크기)씩 증가함을 확인할 수 있을 것이다. 매번 메모리 재할당 및 복사 작업으로 인해, R vector의 원소를 추가할 때마다 필요한 작업량이 파이썬의 array를 사용할 때보다 더 많을 것이며, vector의 길이가 길수록 그 차이가 더 커지게 될 것이다. 4.2.4 문자열 시퀀스 R에서는 각 원소가 문자열인 vector를 각 원소가 하나의 문자인 vector를 생성할 때와 마찬가지 방식으로 생성할 수 있다. r_char_vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) typeof(r_char_vec) ## [1] &quot;character&quot; r_char_vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; r_str_vec &lt;- c(&quot;abc&quot;, &quot;def&quot;) typeof(r_str_vec) ## [1] &quot;character&quot; r_str_vec ## [1] &quot;abc&quot; &quot;def&quot; typeof() 결과에서 보이듯이, 두 가지 경우 모두 R에서는 “character” 형태의 원소를 지닌 vector로 인식한다. 다시 말해, R에서는 문자열의 길이와 상관이 없이 문자형의 데이터를 “character” 형태라고 한다. 이 두 객체에 대해 pryr::inspect()를 호출하면, list에서와 같이 각 원소에 해당하는 메모리 주소가 출력되는 것을 볼 수 있다. 이는 각 원소에 실제 원소값을 저장한 다른 vector와는 달리, 문자열 vector는 list와 마찬가지로 각 원소에 실제 원소값에 대한 주소값을 지니며, 다만 list와는 달리 그 원소값의 형태가 문자열(C에서는 CHARSXP 객체)로 제한된다는 점을 의미한다고 하겠다. pryr::inspect(r_char_vec) ## &lt;STRSXP 0x7fbffa454a28&gt; ## &lt;CHARSXP 0x7fc028ad1148&gt; ## &lt;CHARSXP 0x7fc028e83ae8&gt; ## &lt;CHARSXP 0x7fc02880e0c0&gt; pryr::inspect(r_str_vec) ## &lt;STRSXP 0x7fbffec14fc8&gt; ## &lt;CHARSXP 0x7fbfff2fa438&gt; ## &lt;CHARSXP 0x7fc0291428a8&gt; 문자열에 대해서는 추후 기회가 되면 별도로 다시 다루기로 하자. 4.3 파이썬 NumPy 파이썬의 array와 가장 유사한 R의 자료 구조는 vector라 하겠지만, R의 vector와 가장 유사한 파이썬의 자료 구조는 array.array보다는 numpy.array라 하는 것이 더 적합할 것 같다. NumPy는 파이썬의 기본 라이브러리가 아니라 추가로 설치해야 하는 라이브러리이지만, 대부분의 코딩에서는 연산을 위해 numpy.array를 더 많이 사용할 것이다. 이에 대해서는 추후 기회가 되면 다시 살펴보기로 하자. "],["scalar.html", "Chapter 5 Scalar 5.1 파이썬 5.2 R", " Chapter 5 Scalar 여러 개의 값의 시퀀스가 아니라, 오직 하나의 값만을 지니는 객체를 생각해 보자. 이러한 객체를 생성하는 데는 두 가지 방법을 생각해 볼 수 있다. 별도의 자료구조를 사용하는 방법과, 단순히 길이 1인 시퀀스를 생성하는 방법이다. 전자의 경우 시퀀스의 특성을 제거한 자료구조를 상상해 볼 수 있을 것이며, 후자의 경우 시퀀스 특성이 객체에 여전히 존재할 것이라 상상해 볼 수 있을 것이다. 파이썬에서는 전자의 경우에 해당하는 자료구조가 존재하는 반면, R에서는 후자의 방법을 따른다. 보다 자세한 내용은 예제와 함께 보도록 하자. 5.1 파이썬 파이썬에서는 논리형, 정수형, 실수형 값 각각은 별도의 class 객체이며, 시퀀스가 아니다. 즉, 길이 1의 array가 아니라, 별개의 scalar 객체이다. 우선 논리형을 살펴보자. py_bool = True type(py_bool) ## &lt;class &#39;bool&#39;&gt; 여기에서 py_bool이 시퀀스 객체가 아님을 간단하게 확인하기 위해 함수 len()을 호출해 보자. len(py_bool) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: object of type &#39;bool&#39; has no len() 이 호출은 오류를 반환할텐데, 왜냐하면 bool class에는 시퀀스 클래스들과는 달리 special method __len__()가 정의되어 있지 않기 때문이다. 다음으로 정수형을 살펴보자. py_int = 7 type(py_int) ## &lt;class &#39;int&#39;&gt; 정수형 int class 역시 __len__() method를 지니지 않는다. len(py_int) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: object of type &#39;int&#39; has no len() 또한, 다음과 같은 indexing도 적용되지 않는다. 물론, scalar에 이러한 indexing은 효용성이 없지만, 오류가 반환된다는 점이 중요하다. py_int[0] ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;int&#39; object is not subscriptable 이와 달리, 길이가 1인 정수형 array를 생성해 보면, 이는 array class 객체이며 len()를 호출할 때 길이 1을 반환한다. 또한, indexing이 지원된다. from array import array py_int_array = array(&#39;l&#39;, [7]) type(py_int_array) ## &lt;class &#39;array.array&#39;&gt; len(py_int_array) ## 1 py_int_array[0] ## 7 따라서, Python을 사용할 때 각 논리형, 정수형, 실수형 값은 길이 1인 array가 아니라 array의 특성을 지니지 않은 개별 값임을 기억하자. 5.2 R R에서 논리형, 정수형, 실수형 값 각각은 길이 1인 vector로 표현된다. 따라서, is.vector()에 인자로 넘기면 TRUE를 반환할 것이며, length() 함수를 호출하면 길이 1을 반환할 것이다. 우선 논리형에 대해 확인해 보자. r_bool &lt;- TRUE is.vector(r_bool) ## [1] TRUE length(r_bool) ## [1] 1 다음으로 정수형에 대해 확인해 보자. r_int &lt;- 7L is.vector(r_int) ## [1] TRUE length(r_int) ## [1] 1 따라서, R의 “scalar”는 파이썬의 scalar형 객체가 아닌 파이썬의 array(길이 1인)와 유사하다고 생각할 수 있다. 이는 앞 장에서 파이썬의 array와 R의 vector의 유사성을 살펴보았던 것과 일관된다. "],["interesting-differences.html", "Chapter 6 값을 다룰 때 흥미로운 차이점 6.1 큰 정수 6.2 결측값 6.3 문자열", " Chapter 6 값을 다룰 때 흥미로운 차이점 6.1 큰 정수 매우 큰 정수를 정확한 값으로 사용해야 하는 경우, 파이썬에서는 기본 정수형을 그대로 사용할 수 있겠으나, R에서는 일정 크기 이상의 정수가 정확히 저장되지 않는 문제가 있다. 따라서, 매우 큰 정수값을 사용해야 하는 경우 R에서는 주의하도록 하자. 20자리 정수를 객체에 지정한 뒤, 그 값을 프린트하는 다음 파이썬 코드를 보자. 값이 정확하게 출력된다. 파이썬(보다 정확하게 파이썬3)의 경우, 정수값의 범위에 제한이 없다. py_int = 12345678901234567890 type(py_int) ## &lt;class &#39;int&#39;&gt; print(py_int) ## 12345678901234567890 같은 숫자(마지막에 정수형임을 나타내는 L을 추가)를 R 객체에 입력하려 할 때, 그 값이 정확하게 저장되지 않음을 확인할 수 있다. R은 너무 큰 정수는 실수형(double)으로 받아들이고, 실수형에 적용되는 표현식을 통해 주어진 값에 가깝지만 정확히 같지는 않은 값으로 나타난다. typeof()의 결과가 \"integer\"가 아닌 \"double\"임에 주목하자. r_int &lt;- 12345678901234567890L typeof(r_int) ## [1] &quot;double&quot; format(r_int, digits = 20, scientific = FALSE) ## [1] &quot;12345678901234567168&quot; 이는 파이썬에서 값을 정수가 아닌 실수형(float)으로 입력하였을 때(마지막에 실수형임을 나타내는 . 추가) 나타나는 결과와 동일하다. py_float = 12345678901234567890. type(py_float) ## &lt;class &#39;float&#39;&gt; print(f&#39;{py_float:20.0f}&#39;) ## 12345678901234567168 6.2 결측값 결측값에 대해서는 R을 먼저 살펴보자. R에서는 NA가 결측값을 나타낸다. 일반적으로는 데이터의 형태와 상관없이 NA를 사용하지만, 이는 사실 논리형에 대한 결측값이며, 다른 형태, 즉 정수형(NA_integer_), 실수형(NA_real_), 문자형(NA_character_)의 결측값도 각각 존재한다. typeof(NA) ## [1] &quot;logical&quot; typeof(NA_integer_) ## [1] &quot;integer&quot; typeof(NA_real_) ## [1] &quot;double&quot; typeof(NA_character_) ## [1] &quot;character&quot; 데이터 형태와 상관없이 NA를 써도, vector에 있는 다른 관측값들의 형태와 일관된 결측값으로 자동으로 적용된다. str(NA) ## logi NA str(NA_integer_) ## int NA str(c(5L, NA)[2]) ## int NA 파이썬에서는 기본적으로 None이 결측값을 표현하는데 사용된다. None type(None) ## &lt;class &#39;NoneType&#39;&gt; 이 결측값은 정수형, 실수형, 문자형 array.array에 원소로 추가할 수가 없다. from array import array array(&#39;l&#39;, [5, None]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: an integer is required (got type NoneType) array(&#39;f&#39;, [5., None]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: must be real number, not NoneType array(&#39;u&#39;, [&#39;5&#39;, None]) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: array item must be unicode character 대신, 결측값을 NumPy array에 입력해 보자. NumPy는 np.nan이라는 실수형 결측값을 지원하며, 이를 사용하는 것이 흔한 경우다. 이때 array 내에 존재하는 다른 관측값의 형태에 따라 type coercion에 의해 예상치 않은 결과를 얻을 수 있으니 조심하도록 하자. import numpy as np type(np.nan) ## &lt;class &#39;float&#39;&gt; 실수형 array에 이 결측값을 추가하는 경우에는 여전히 실수형 array로 나타날 것이다. np.array([5., np.nan]) ## array([ 5., nan]) 정수형 array에 결측값을 추가했을 때는 이 array 자체가 실수형으로 변하는데, 이는 데이터 형태에서 실수형인 결측값이 정수형인 관측값들보다 데이터 형태 결정 시 우선순위에 있기 때문으로 보인다. np.array([5, np.nan]) ## array([ 5., nan]) np.array([5, np.nan])[0] ## 5.0 문자형 array에 결측값을 추가했을 때는 결측값이 문자열 'nan'으로 변한다. Type coercion상 문자형이 실수형보다 우위에 있기 때문으로 보인다. np.array([&#39;5&#39;, np.nan]) ## array([&#39;5&#39;, &#39;nan&#39;], dtype=&#39;&lt;U32&#39;) type(np.array([&#39;5&#39;, np.nan])[1]) ## &lt;class &#39;numpy.str_&#39;&gt; 6.3 문자열 파이썬과 R이 문자열을 다루는 방식을 조금 들여다보자. 우선 파이썬으로 문자열 객체를 만들어 보자. 객체 형태가 str로 나타난다. 이는 문자의 시퀀스이며, immutable object이다. py_string = &quot;Hello Python!&quot; type(py_string) ## &lt;class &#39;str&#39;&gt; 시퀀스이기 때문에, slicing 등이 지원된다. py_string[0:5] ## &#39;Hello&#39; 파이썬에서 이 특정 문자열을 위한 메모리 주소와 할당량을 보자. id(py_string) ## 4641962672 sys.getsizeof(py_string) ## 62 이제, 파이썬 리스트를 만들고, 각 원소에 동일한 문자열을 저장해 보자. 이 때, 같은 문자열 객체를 재사용하는 것이 아니라, 매번 새롭게 동일한 문자열 값을 저장해 보자. 만약 for문을 사용한다면, 파이썬은 모든 같은 문자열을 같은 메모리에 저장하고, list의 모든 원소가 같은 메모리 주소를 참조하도록 할 것이다. 파이썬에서 for문이 메모리를 좀 더 효율적으로 사용하기 위한 어떤 처리를 하는 것으로 보인다. py_list = list([None] * 5) for i in range(5): py_list[i] = &quot;Hello Python!&quot; [id(x) for x in py_list] ## [4641976176, 4641976176, 4641976176, 4641976176, 4641976176] 하지만, 만약 for문을 사용하지 않고 매번 새롭게 원소를 추가하는 경우라면, 파이썬은 같은 문자열을 다른 메모리 주소에 저장할 것이다. py_list = list([None] * 5) py_list[0] = &quot;Hello Python!&quot; py_list[1] = &quot;Hello Python!&quot; py_list[2] = &quot;Hello Python!&quot; py_list[3] = &quot;Hello Python!&quot; py_list[4] = &quot;Hello Python!&quot; [id(x) for x in py_list] ## [4641985008, 4641985072, 4641985264, 4641985456, 4641985648] 이와 같이 같은 값의 immutable 문자열을 메모리의 여러 곳에 중복하여 저장하는 것은 경우에 따라 메모리의 사용이 다소 비효율적일 수 있음을 보인다. 다음으로 R의 경우를 살펴보자. R은 문자열을 “character”라는 형태의 데이터로 저장한다. 이는 R 내에서는 vector와 같은 시퀀스가 아니라 하나의 독립적인 값으로 다루어지기 때문에, [] operator를 사용하여 문자열의 일부를 slicing할 수 없고, 별도의 함수들을 사용하여 추출해야 한다. 예를 들어, 다음 코드의 결과는 아마 기대와 다를 것이다. 무슨 일이 일어나고 있는지 잠시 생각해 보면, r_string은 character 형태의 길이가 1인 vector이고, 따라서 r_string[1]은 입력한 문자열을 반환하고, r_string[2:5]는 해당 원소가 존재하지 않으므로 NA를 반환한다. r_string &lt;- &quot;Hello R!&quot; typeof(r_string) ## [1] &quot;character&quot; r_string[1:5] ## [1] &quot;Hello R!&quot; NA NA NA NA 이 경우, r_string에 입력한 문자열의 첫 다섯 개의 문자를 가져오기 위해서는 문자열을 다루는 함수를 사용해야 할 것이다. substr(r_string, 1, 5) ## [1] &quot;Hello&quot; r_string에 할당된 메모리 주소 정보를 살펴보자. pryr::inspect(r_string) ## &lt;STRSXP 0x7fdd454f6668&gt; ## &lt;CHARSXP 0x7fdd622f6708&gt; ## attributes: ## &lt;CHARSXP 0x7fdd6017c740&gt; 여기에서 최상위 STRSXP는 vector를 나타내며, CHARSXP는 vector의 원소인 문자열을 나타낸다. 파이썬의 경우와 마찬가지로 시퀀스에 문자열을 입력해 보자. 모든 원소가 문자열이기 때문에 list 대신 vector를 사용해서 보도록 하자. 파이썬에서 다소 비효율적으로 보였던 메모리 관리와 비교하기 위해, R에서도 for문을 사용하지 않고 원소 하나 하나에 값을 따로 할당하도록 하자. r_vector &lt;- vector(&quot;character&quot;, 5L) r_vector[[1]] &lt;- &quot;Hello R!&quot; r_vector[[2]] &lt;- &quot;Hello R!&quot; r_vector[[3]] &lt;- &quot;Hello R!&quot; r_vector[[4]] &lt;- &quot;Hello R!&quot; r_vector[[5]] &lt;- &quot;Hello R!&quot; pryr::inspect()를 이용하여 이 vector 객체의 메모리 사용을 살펴보면, 다섯 개 문자열 원소 모두 동일한 메모리 주소를 참조하는 것을 볼 수 있다. 이에 더하여, 그 메모리 주소가 앞서 생성했던 r_string의 원소인 문자열의 메모리 주소와 동일함을 확인할 수 있다. R에서는 하나의 R 세션 내에서 각 고유한 문자열값이 메모리 한 곳에만 저장되며, 나중에 동일한 문자열값을 다시 생성하려 하면, 중복하여 다른 위치에 생성하는 대신, 기존에 저장된 메모리를 참조한다. 이 방식을 통해 R은 매우 긴 동일한 문자열이 여러 이름 혹은 시퀀스의 여러 위치에 중복되는 경우 메모리를 효율적으로 사용할 수 있을 것이다. pryr::inspect(r_vector) ## &lt;STRSXP 0x7fdd623624e8&gt; ## &lt;CHARSXP 0x7fdd622f6708&gt; ## attributes: ## &lt;CHARSXP 0x7fdd6017c740&gt; ## [CHARSXP 0x7fdd622f6708] ## [CHARSXP 0x7fdd622f6708] ## [CHARSXP 0x7fdd622f6708] ## [CHARSXP 0x7fdd622f6708] "],["date-time.html", "Chapter 7 날짜 및 시간 7.1 날짜 7.2 날짜/시간 7.3 시간", " Chapter 7 날짜 및 시간 날짜와 시간이 파이썬과 R에서 어떻게 저장되는지 알아보자. 날짜와 시간은 다루기 까다로운 부분들이 존재하기 때문에 이를 위한 패키지(예: R의 lubridate)들이 개발되어 있다. 하지만, 이 책에서는 사용자의 추가적인 설치 없이 기본적으로 제공되는 패키지/모듈에 기반하여 살펴보기로 하자. 따라서, 파이썬에서는 datetime 모듈에 기반하여 살펴볼 것이며, R에서는 base 패키지에 기반하여 살펴볼 것이다. 7.1 날짜 7.1.1 파이썬 파이썬에서는 datetime 모듈의 date 클래스 객체로 날짜를 저장한다. 객체를 생성하는 가장 기본적인 방법으로는 year, month, day를 순서대로 생성자의 인자로 입력하는 방법이 있다. from datetime import date py_date = date(2022, 7, 5) py_date ## datetime.date(2022, 7, 5) type(py_date) ## &lt;class &#39;datetime.date&#39;&gt; 다른 방법으로는 클래스 메서드 date.fromisoformat()를 사용하여 ISO 표준 형식의 날짜를 문자열로 입력하는 방법이 있다. date.fromisoformat(&#39;2022-07-05&#39;) ## datetime.date(2022, 7, 5) 파이썬의 date 클래스의 객체는 연, 월, 일의 세 가지 속성값을 지닌다. py_date.year ## 2022 py_date.month ## 7 py_date.day ## 5 7.1.1.1 Day differences 두 날짜를 - 연산자를 이용하여 빼면 timedelta 클래스의 객체를 반환한다. date.fromisoformat(&#39;2022-07-06&#39;) - py_date ## datetime.timedelta(days=1) date.fromisoformat(&#39;2022-07-04&#39;) - py_date ## datetime.timedelta(days=-1) date.fromisoformat(&#39;2023-01-01&#39;) - py_date ## datetime.timedelta(days=180) timedelta 객체는 두 날짜의 차이를 days 속성값으로 지닌다. (date.fromisoformat(&#39;2023-01-01&#39;) - py_date).days ## 180 7.1.1.2 Offset 기존 날짜에 어떠한 기간을 더하거나 뺀 날짜를 얻고자 할 때, 단순히 숫자를 더하거나 빼려고 시도하면 오류를 얻게 된다. py_date + 180 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for +: &#39;datetime.date&#39; and &#39;int&#39; 대신, 앞에서 보았던 timedelta 객체를 이용한다. from datetime import timedelta py_date + timedelta(days=180) ## datetime.date(2023, 1, 1) 7.1.2 R R에서는 as.Date() 함수에 ISO 표준 형식의 날짜를 문자열로 입력하여 Date 클래스 객체를 생성할 수 있다. r_date &lt;- as.Date(&quot;2022-07-05&quot;) r_date ## [1] &quot;2022-07-05&quot; class(r_date) ## [1] &quot;Date&quot; 입력 문자열이 ISO 표준 형식이 아닌 경우, format 인자에 입력 문자열의 형식을 명시함으로써 값을 올바르게 읽을 수 있다. as.Date(&quot;05/07/2022&quot;, format = &quot;%d/%m/%Y&quot;) ## [1] &quot;2022-07-05&quot; as.Date(&quot;Jul 5, 2022&quot;, format = &quot;%b %d, %Y&quot;) ## [1] &quot;2022-07-05&quot; R의 Date 클래스를 사용할 때 중요하게 이해할 점은, 이 클래스의 기반에 존재하는 값이 숫자형(double)이라는 점이다. typeof(r_date) ## [1] &quot;double&quot; 클래스 속성을 제거하여, 생성한 날짜 객체의 기반에 있는 숫자값을 출력해 보자. unclass(r_date) ## [1] 19178 이 숫자는 1970-01-01로부터 날이 얼마나 지났는지를 표현한다. 즉, 1970-01-01은 0, 1970-01-02는 1, 1969-12-31은 -1의 값을 지닌다. unclass(as.Date(&quot;1970-01-01&quot;)) ## [1] 0 unclass(as.Date(&quot;1970-01-02&quot;)) ## [1] 1 unclass(as.Date(&quot;1969-12-31&quot;)) ## [1] -1 7.1.2.1 Day differences 두 날짜 사이의 기간을 - 연산자를 사용하여 계산해 보자. r_diff &lt;- as.Date(&quot;2023-01-01&quot;) - r_date r_diff ## Time difference of 180 days 이 객체의 클래스는 difftime이며, 그 기저에 있는 값의 형태는 숫자형(double)이다. class(r_diff) ## [1] &quot;difftime&quot; typeof(r_diff) ## [1] &quot;double&quot; 클래스 속성을 제거하여 값을 확인해 보자. unclass(r_diff) ## [1] 180 ## attr(,&quot;units&quot;) ## [1] &quot;days&quot; 7.1.2.2 Offset R의 Date 객체는 기본적으로 숫자형 데이터이므로, 여기에 숫자를 더하거나 빼서 편리하게 새로운 날짜를 얻을 수 있다. r_date + 180 ## [1] &quot;2023-01-01&quot; 물론, 명시적으로 difftime 객체를 생성하여 수행할 수도 있다. r_date + as.difftime(180, units = &quot;days&quot;) ## [1] &quot;2023-01-01&quot; 7.2 날짜/시간 날짜 뿐만 아니라 시간을 함께 저장하는 데이터 종류를 살펴보자. 7.2.1 파이썬 datatime 모듈의 datetime 클래스가 이를 지원한다. 객체를 만들 때 생성자에 앞에서 살펴보았던 연, 월, 일 외에 추가로 시간, 분, 초, 마이크로초(0 ~ 999999)를 입력하여 생성할 수 있다. from datetime import datetime py_datetime = datetime(2022, 7, 5, 12, 34, 56, 987654) py_datetime ## datetime.datetime(2022, 7, 5, 12, 34, 56, 987654) type(py_datetime) ## &lt;class &#39;datetime.datetime&#39;&gt; 이 때, 마이크로초는 정수여야 하며, 더 작은 단위의 시간을 입력하려 실수형을 입력하면 오류가 발생한다. datetime(2022, 7, 5, 12, 34, 56, 987654.3) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: integer argument expected, got float 클래스 메서드 fromisoformat()을 이용하여 문자열 형태의 표현으로부터 datetime 클래스 객체를 생성할 수 있다. 주의: 초를 소수점 이하 세 자리, 즉, 밀리초까지만 입력할 수 있으며, 네 자리 이상 입력하려 시도하면 오류가 발생한다. datetime.fromisoformat(&#39;2022-07-05T12:34:56.987&#39;) ## datetime.datetime(2022, 7, 5, 12, 34, 56, 987000) 클래스 메서드 strptime()는 포맷에 더 유연하며, 마이크로초 단위까지 입력받을 수 있다. datetime.strptime(&#39;2022-07-05 12:34:56.987654&#39;, &#39;%Y-%m-%d %H:%M:%S.%f&#39;) ## datetime.datetime(2022, 7, 5, 12, 34, 56, 987654) 7.2.1.1 Datietime differences 두 날짜/시간 값을 - 연산자를 이용하여 빼면 timedelta 클래스의 객체를 반환한다. py_timedelta = datetime.fromisoformat(&#39;2023-01-01&#39;) - py_datetime py_timedelta ## datetime.timedelta(days=179, seconds=41103, microseconds=12346) 이 때, - 연산자 앞의 객체를 생성할 때 날짜만 입력하였음을 주목하자. datetime 객체를 생성할 때, 시간 이하의 인자는 생략될 경우 0을 기본값으로 사용한다. 또한, timedelta 객체가 days, seconds, microseconds의 속성값을 지니는 것에 주목하자. 시간과 분 단위의 차이는 초 단위의 차이로 변환된다. 다음과 같이 date객체와 datetime 객체간의 시간 차이를 계산하려 하면 오류가 발생한다. (다음에서 datetime.fromisoformat()이 아닌 date.fromisoformat()을 사용하려 하였음을 주목하자.) date.fromisoformat(&#39;2023-01-01&#39;) - py_datetime ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for -: &#39;datetime.date&#39; and &#39;datetime.datetime&#39; 7.2.2 R R의 base 패키지에서 제공하는 날짜/시간 클래스로는 POSIXct와 POSIXlt가 있다. 이 두 클래스가 표현하는 값은 기본적으로 같으나, 내부적으로 저장되는 방법이 서로 다르다. 마이크로초 단위의 값을 출력하기 위해, R 세션의 digits 옵션을 변경하자. options(digits = 20) 7.2.2.1 POSIXct as.POSIXct() 함수를 사용하여 문자열로부터 POSIXct 클래스 객체를 생성하자. format 인자를 사용하여 다양한 포맷의 문자열로부터 값을 읽을 수 있으나, 본 장에서는 기본 포맷을 사용하기로 하자. r_datetime_ct &lt;- as.POSIXct(&quot;2022-07-05 12:34:56.987654&quot;) r_datetime_ct ## [1] &quot;2022-07-05 12:34:56 EDT&quot; class(r_datetime_ct) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 여기에 출력된 값에는 초의 소숫점 이하는 생략되어 있으며, 마지막에 시간대(timezone) 정보가 추가되어 출력된다. 우선, 시간대 정보는 신경쓰지 말자. 출력된 값의 기저에 실수형 값이 저장되어 있음을 typeof()를 통해 알 수 있다. typeof(r_datetime_ct) ## [1] &quot;double&quot; 정확히 어떠한 값이 저장되어 있는지를 알아보기 위해 unclass()를 실행해 보자. unclass(r_datetime_ct) ## [1] 1657038896.9876539707 ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; 이 실수형 값은 정수 부분과 소숫점 이하의 부분으로 나뉜다. 7.2.2.1.1 소숫점 이하 부분 우선 소숫점 이하 부분부터 살펴보자. 실수형 값에서 우선 소숫점 이하의 값이 입력된 마이크로초 정보와 매우 근사하지만 정확히 같이 않음을 볼 수 있다. 입력된 정보와 정확히 같기 위해서는 .9876540000이어야 하겠지만, 실제 저장된 값을 출력해 보면 .9876539707과 같이 미세하게 다르다. 실수형 데이터는 정확한 값이 아니라 그 값에 근사한 값을 표현하는 형태로 저장되기 때문에 이러한 차이가 발생한다. 이는 R과 파이썬이 다른 부분이다. R은 실수형으로 저장하기 때문에 마이크로초 이하 단위의 시간도 표현 가능한 반면, 저장하고자 했던 정확한 값을 저장하지 못한다. 파이썬은 마이크로초 정보를 따로 정수형으로 저장하기 때문에, 저장하고자 했던 정확한 값을 저장하는 반면, 만약 애초에 저장하고자 했던 정보가 마이크로초 이하라면, 그 시간 정보를 저장할 수 없다. 7.2.2.1.2 정수 부분 다음으로, 정수 부분을 살펴보자. 정수 부분은 초 단위까지 표현하는 부분이다. unclass(as.POSIXct(&quot;2022-07-05 12:34:56&quot;)) ## [1] 1657038896 ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; 좀 더 정확하게는, 협정 세계시(Coordinated Universal Time; UTC) 기준 1970년 1월 1일 0시 0분 0초부터 소요된 초이다. 다시 말하면, 다음 코드는 0을 반환한다. unclass(as.POSIXct(&quot;1970-01-01 00:00:00&quot;, tz = &quot;UTC&quot;)) ## [1] 0 ## attr(,&quot;tzone&quot;) ## [1] &quot;UTC&quot; 다음 코드는 86,400을 반환할텐데, 이는 하루가 86,400초이기 때문이다. unclass(as.POSIXct(&quot;1970-01-02 00:00:00&quot;, tz = &quot;UTC&quot;)) ## [1] 86400 ## attr(,&quot;tzone&quot;) ## [1] &quot;UTC&quot; 여기서 tz = \"UTC\" 인자를 사용했음에 주목하자. 이를 명시하지 않으면, 각자의 R 세션에 설정된 시간대를 기본값으로 사용하며, 이는 \"UTC\"를 사용할 때와는 다른 값을 반환한다. 다음의 예를 보자. unclass(as.POSIXct(&quot;1970-01-02 00:00:00&quot;)) ## [1] 104400 ## attr(,&quot;tzone&quot;) ## [1] &quot;&quot; unclass(as.POSIXct(&quot;1970-01-02 00:00:00&quot;, tz = Sys.timezone())) ## [1] 104400 ## attr(,&quot;tzone&quot;) ## [1] &quot;America/New_York&quot; 날짜/시간 객체가 표현하는 시간대는 tz 인자를 통해 설정할 수 있지만, 그 기저의 값은 항상 협정 세계시(Coordinated Universal Time; UTC) 기준 1970년 1월 1일 0시 0분 0초부터 얼마나 지났는지를 나타낸다. 7.2.2.2 POSIXlt 다음으로 POSIXlt 클래스 객체를 생성해 보자. as.POSIXlt() 함수를 사용하며, 함수 사용 방법은 as.POSIXct()와 마찬가지다. r_datetime_lt &lt;- as.POSIXlt(&quot;2022-07-05 12:34:56.987654&quot;) r_datetime_lt ## [1] &quot;2022-07-05 12:34:56 EDT&quot; class(r_datetime_lt) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; 이는 리스트로 저장되어 있는 보다 구조적인 데이터다. typeof(r_datetime_lt) ## [1] &quot;list&quot; 정확히 어떠한 값이 저장되어 있는지를 알아보기 위해 unclass()를 실행해 보자. unclass(r_datetime_lt) ## $sec ## [1] 56.987653999999999144 ## ## $min ## [1] 34 ## ## $hour ## [1] 12 ## ## $mday ## [1] 5 ## ## $mon ## [1] 6 ## ## $year ## [1] 122 ## ## $wday ## [1] 2 ## ## $yday ## [1] 185 ## ## $isdst ## [1] 1 ## ## $zone ## [1] &quot;EDT&quot; ## ## $gmtoff ## [1] NA 여기에서 주목할 두 가지 부분이 있다. POSIXct에서 정수 부분에 함께 포함되어 있던 여러가지 정보가 POSIXlt에서는 여러 원소로 나뉘어 저장되어 있다. 시간대 정보 또한 zone 원소로 저장되어 있다. 초 단위 이하의 정보는 sec 원소로 저장되어 있는데, 여기에서 소숫점 이하의 값이 앞에서 POSIXct에서 봤던 값과 다소 다를 수 있다. 이는 다시금 실수값의 저장 방식(근사치)과 관련이 있을 것이다. POSIXct에서는 실수값에서 정수 부분의 유효숫자가 매우 많았던 반면, POSIXlt에서는 초 단위 이하만 따로 sec에서 관리하므로 정수 부분의 유효숫자가 적고(두 자리), 따라서 소숫점 이하의 초 단위 정보를 보다 가까운 근사치로 표현할 수 있다. 7.2.2.3 Datietime differences 두 날짜/시간 값을 - 연산자를 이용하여 빼면 timediff 클래스의 객체를 반환한다. r_timediff &lt;- as.POSIXct(&quot;2023-01-01&quot;) - r_datetime_lt r_timediff ## Time difference of 179.51739597622719202 days class(r_timediff) ## [1] &quot;difftime&quot; 이 기저의 값은 실수형(double)이며, 기본으로 일 단위로 나타난다. unclass(r_timediff) ## [1] 179.51739597622719202 ## attr(,&quot;units&quot;) ## [1] &quot;days&quot; 다른 단위로 그 차이를 알고 싶다면 as.double() 호출 시 units 인자를 제공할 수 있다. as.double(r_timediff, units = &quot;secs&quot;) ## [1] 15510303.012346029282 as.double(r_timediff, units = &quot;hours&quot;) ## [1] 4308.4175034294530633 timediff 객체 자체에 저장된 단위를 변경하고 싶다면 units&lt;- 함수를 사용하면 된다. 하지만, 파이썬과 같이 각 단위를 분리하여 좀 더 표현하기 쉽게 보여주고 저장하지는 못한다. 파이썬과 마찬가지로, 날짜값에서 날짜/시간값을 빼는 연산을 수행할 수 없다. 그 결과는 POSIXct를 사용할 때와 POSIXlt를 사용할 때가 다르다. POSIXct를 사용할 때는 기저의 값이 실수형이므로, 마찬가지로 기저의 값이 실수형인 Date와의 연산이 특별한 구현 없이도 R에서 기술적으로 가능하다. 하지만, 그 값의 단위가 다르기 때문에 (POSIXct는 초, Date는 일), 의미가 결과값이 나타나게 될 것이다. 이때, R은 warning 메시지를 출력하며, 결과의 클래스는 - 연산자 앞에 놓인 객체의 클래스에 따라 생성된다. as.Date(&quot;2023-01-01&quot;) - r_datetime_ct ## Warning: Incompatible methods (&quot;-.Date&quot;, &quot;-.POSIXt&quot;) for &quot;-&quot; ## [1] &quot;-4534796-08-05&quot; r_datetime_ct - as.Date(&quot;2023-01-01&quot;) ## Warning: Incompatible methods (&quot;-.POSIXt&quot;, &quot;-.Date&quot;) for &quot;-&quot; ## [1] &quot;2022-07-05 07:12:18 EDT&quot; 반면, POSIXlt는 기저의 자료 형태가 리스트이므로, 기저의 값이 실수형인 Date와 연산이 특별한 구현 없이는 기본적으로 정의되지 않는다. 따라서 이는 오류를 발생시킨다. as.Date(&quot;2023-01-01&quot;) - r_datetime_lt ## Warning: Incompatible methods (&quot;-.Date&quot;, &quot;-.POSIXt&quot;) for &quot;-&quot; ## Error in as.Date(&quot;2023-01-01&quot;) - r_datetime_lt: non-numeric argument to binary operator 7.3 시간 날짜와 상관 없이 시간만 중요한 경우를 가정해 보자. 이 때, 날짜는 저장하지 않고 시간만 따로 저장하고 싶을 것이다. 7.3.1 파이썬 파이썬은 datetime 모듈의 time 클래스를 사용하여 시간만 따로 저장할 수 있도록 한다. 생성자 time()에 시간, 분, 초, 마이크로초(0 ~ 999999)를 입력하여 생성할 수 있다. from datetime import time py_time = time(12, 34, 56, 987654) py_time ## datetime.time(12, 34, 56, 987654) type(py_time) ## &lt;class &#39;datetime.time&#39;&gt; 이 때, datetime과 마찬가지로 마이크로초는 정수여야 하며, 더 작은 단위의 시간을 입력하려 실수형을 입력하면 오류가 발생한다. time(12, 34, 56, 98765.4) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: integer argument expected, got float 7.3.1.1 Time differences 파이썬에서 time 객체간 차이를 - 연산자를 사용하여 직접 계산할 수는 없다. py_time - time(12, 0, 0) ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for -: &#39;datetime.time&#39; and &#39;datetime.time&#39; 이를 위해서는 datetime 객체를 생성한 뒤에 차이를 구해야 한다. datetime.combine(date = date.min, time = py_time) -\\ datetime.combine(date = date.min, time = time(12, 0, 0)) ## datetime.timedelta(seconds=2096, microseconds=987654) 7.3.2 R 기본적으로 R에는 날짜와 분리된 별도의 시간 자료 형태가 없다. 따라서 (별도의 추가적인 패키지를 사용하지 않는 한) 앞에서 살펴본 날짜/시간 클래스를 적절히 사용해야 한다. r_time &lt;- as.POSIXlt(&quot;12:34:56.987654&quot;, format = &quot;%H:%M:%OS&quot;) r_time ## [1] &quot;2022-07-04 12:34:56 EDT&quot; class(r_time) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; r_time - as.POSIXlt(&quot;12:00:00&quot;, format = &quot;%H:%M:%S&quot;) ## Time difference of 34.949794232845306396 mins "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
