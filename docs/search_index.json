[["index.html", "Python &amp; R Chapter 1 Overview 1.1 Python 1.2 R", " Python &amp; R 이영록 2022-06-12 Chapter 1 Overview 이 책은 Python과 R의 비슷한 점과 차이점을 예제를 통해 알아보기 위한 책이다. 어느 하나가 다른 하나의 우위에 있음을 보이려는 의도가 아니며, Python 사용자가 R을 이해하거나 R 사용자가 Python을 이해하는 데 도움을 주기 위해 작성되었다. 특정 용도(통계 분석, 시각화, 머신 러닝 등)보다는 일반적인 프로그래밍 언어 관점에서 살펴보고자 한다. 따라서 가능한 한 기본 Python 및 R의 내에서 비교하며, R의 경우에는 필요에 따라 R을 좀 더 프로그래밍 언어적으로 사용하기 위한 패키지(rlang 등)를 필요에 따라 추가로 사용할 예정이다. 책 작성 시 사용된 Python과 R의 버전은 다음과 같다. 1.1 Python import sys print(sys.version) ## 3.8.9 (default, Apr 13 2022, 08:48:07) ## [Clang 13.1.6 (clang-1316.0.21.2.5)] 1.2 R R.version$version.string ## [1] &quot;R version 4.1.3 (2022-03-10)&quot; "],["dictionary-named-list-environment.html", "Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 2.1 Dictionary in Python 2.2 Named list vs environment in R", " Chapter 2 파이썬의 dictionary, 그리고 R의 named list와 environment 다음과 같은 조건을 충족하기 위한 자료 구조를 생각해 보자. 자료는 여러 원소(element)를 지닌다. 각 원소는 키(key)–혹은 이름(name)–와 값(value)의 쌍으로 이루어진다. 각 원소의 값은 서로 다른 형태(type)일 수 있다. 파이썬에서 이 조건들을 동시에 충족하는 대표적인 자료 구조는 dictionary이다. Tuple과 list는 조건 2를 충족하지 못한다. R의 경우에는 list(보다 구체적으로 named list)와 environment가 세 조건을 모두 충족한다. 그렇다면, named list와 environment 중 어떤 것이 파이썬의 dictionary와 더 비슷할까? 필자는 environment가 더 비슷하다고 생각한다. 다음은 R의 environment만 지닌 파이썬의 dictionary과의 공통점이다. Hash를 사용하여 원소를 빨리 lookup할 수 있다. 원소 이름이 unique해야 한다. Reference semantics를 지닌다(modify-in-place를 지원한다). Position을 사용한 인덱싱이 지원되지 않는다. 여러 원소를 한번에 읽을 수 없다. 반면, R의 list만 파이썬의 dictionary와 지닌 공통점은 다음과 같다. 원소가 생성된 순서가 보존된다. 여기에서 어떠한 공통점이 중요한지에 따라 파이썬의 dictionary와 대응하여 사용하기에 더 적합한 R의 자료 구조를 선택해야 할 것이다. 본 장에서는 아래와 같은 문제 상황에서 environment가 더 적합한 자료 구조임을 보일 것이다. 원소가 생성된 순서는 의미가 없다. 얼마나 많은 원소가 생성될 지 미리 알 수 없으며, 중간에 원소가 삭제될 수도 있는데, 이 때 처리 속도가 빨라야 한다. 각 원소는 자주 읽히기 때문에, 자료를 찾는 속도가 빨라야 한다. 참고로, 파이썬의 dictionary가 R의 environment나 list보다 유연한 부분이 있다. 파이썬의 dictionary에서 key는 어떠한 immutable 객체라도 사용할 수 있는 반면, R의 environment와 named list는 모두 문자열만을 name으로 사용할 수 있다. 2.1 Dictionary in Python 2.1.1 생성 전체 원소 갯수가 미리 정해지지 않은 경우에는 새로운 원소가 들어올 때마다 하나씩 원소를 추가해야 한다. 다음처럼 for loop를 사용하여 원소를 순차적으로 추가하는 시뮬레이션 함수를 만들자. 이 때, key 값을 “item1”, “item2”, … 와 같이 지정하자. def gen_dict(n): ret = {} for x in range(1, n + 1): ret[f&#39;item{x}&#39;] = x return ret py_dict = gen_dict(10000) 결과를 출력할 때, 원소가 입력된 순서가 보존되어 출력된다. [x for x in py_dict.__iter__()][:10] ## [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;, &#39;item4&#39;, &#39;item5&#39;, &#39;item6&#39;, &#39;item7&#39;, &#39;item8&#39;, &#39;item9&#39;, &#39;item10&#39;] 2.1.2 Lookup Key가 “item100”인 원소의 값을 다음과 같이 얻을 수 있다. py_dict[&#39;item100&#39;] ## 100 Dictionary의 경우 position을 사용할 수 없다. py_dict[99] ## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 99 또한, dictionary의 경우 여러 key를 사용하여 한꺼번에 여러 원소의 값을 읽을 수 없다. py_dict[[&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;]] ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; 2.1.3 Reference semantics 두 개의 객체 이름이 같은 dictionary 객체에 binding되었다면, 하나의 객체 이름을 이용하여 특정 원소의 값을 변경하였을 때, reference semantics에 의해 다른 하나의 객체 이름을 이용한 참조 시에도 변경된 값이 나타난다. id(py_dict) ## 4525661056 new_dict = py_dict new_dict[&#39;item100&#39;] = 0 id(new_dict) ## 4525661056 py_dict[&#39;item100&#39;] ## 0 2.2 Named list vs environment in R 위의 파이썬 예를 R에서 named list와 environment 두 가지를 이용해서 각각 구현해 보고, 결과 및 수행 시간을 비교해 보자. 2.2.1 생성 우선 named list를 생성해 보자. 아래 함수가 리스트 길이 n을 인자로 받기 때문에, 빈 리스트를 만든 뒤에 원소를 하나씩 추가하는 코드가 비효율적으로 보일 것이다. 하지만, 여기에서 시뮬레이션을 하려는 상황이 우리가 미리 얼마나 많은 원소가 언제 어떤 이름과 값으로 생성될 지 모르는 상황이라는 점을 기억하자. 따라서, 아래 함수는 단지 비어있는 리스트로 시작하여 원소를 하나씩 추가해야만 하는 경우 수행 시간이 얼마나 걸릴지를 시뮬레이션하기 위한 코드이다. gen_list &lt;- function(n) { ret &lt;- list() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_list &lt;- gen_list(10000)) ## user system elapsed ## 0.768 0.021 0.789 gen_env &lt;- function(n) { ret &lt;- new.env() for (x in seq_len(n)) { ret[[paste0(&#39;item&#39;, x)]] &lt;- x } ret } system.time(r_env &lt;- gen_env(10000)) ## user system elapsed ## 0.030 0.000 0.031 이 결과에서, list에 원소를 하나씩 새로 추가하는 것(즉, 길이가 하나씩 증가하는 것)에 비해, environment에 원소를 하나씩 새로 추가하는 시간이 훨씬 짧게 소요되는 것을 확인할 수 있다. 그 차이는 원소의 갯수가 많을수록 더 커진다. 다음 코드는 원소가 입력된 순서가 보존되는지 확인하기 위한 코드이다. names(r_list)[1:10] ## [1] &quot;item1&quot; &quot;item2&quot; &quot;item3&quot; &quot;item4&quot; &quot;item5&quot; &quot;item6&quot; &quot;item7&quot; &quot;item8&quot; ## [9] &quot;item9&quot; &quot;item10&quot; names(r_env)[1:10] ## [1] &quot;item7082&quot; &quot;item7083&quot; &quot;item7084&quot; &quot;item7085&quot; &quot;item7086&quot; &quot;item5320&quot; ## [7] &quot;item7087&quot; &quot;item5321&quot; &quot;item7088&quot; &quot;item5322&quot; 이 결과에서, list는 순서가 보존되지만, environment는 그렇지 않음을 볼 수 있다. 따라서, 원소 입력 순서를 아는 것이 중요하지 않은 경우에만 environment를 사용하는 것이 적합할 것이다. 2.2.2 Lookup Named list와 environment 모두 원소의 이름을 사용하여 원소의 값을 읽어올 수 있다. r_list[[&quot;item100&quot;]] ## [1] 100 r_env[[&quot;item100&quot;]] ## [1] 100 하지만 그 수행 시간은 사뭇 다르다. 다음 벤치마크를 보자. bench::mark( r_list[[&quot;item100&quot;]], r_env[[&quot;item100&quot;]] ) ## # A tibble: 2 × 6 ## expression min median `itr/sec` mem_alloc `gc/sec` ## &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; ## 1 r_list[[&quot;item100&quot;]] 1.04µs 1.17µs 845015. 0B 0 ## 2 r_env[[&quot;item100&quot;]] 83ns 125ns 6819017. 0B 0 수행 시간의 median값을 볼 때, 이 예에서 environment가 list보다 몇 배 더 빠르다는 것을 확인할 수 있다. Environment는 파이썬의 dictionary와 마찬가지로 position을 사용하거나 여러 원소 이름을 동시에 사용하여 원소값을 읽을 수 없다. r_env[[100]] ## Error in r_env[[100]]: wrong arguments for subsetting an environment r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## Error in r_env[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)]: object of type &#39;environment&#39; is not subsettable 하지만 list는 이것이 가능하다. r_list[[100]] ## [1] 100 r_list[c(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;)] ## $item1 ## [1] 1 ## ## $item2 ## [1] 2 ## ## $item3 ## [1] 3 2.2.3 Reference semantics Environment는 reference semantics을 지녀 modify-in-place 방식으로 작동한다. pryr::address(r_env) ## [1] &quot;0x7fca90279190&quot; new_env &lt;- r_env new_env[[&#39;item100&#39;]] = 0 pryr::address(new_env) ## [1] &quot;0x7fca90279190&quot; r_env[[&#39;item100&#39;]] ## [1] 0 반면, list는 copy-on-modify 방식으로 작동한다. pryr::address(r_list) ## [1] &quot;0x7fca890c0000&quot; new_list &lt;- r_list new_list[[&#39;item100&#39;]] = 0 pryr::address(new_list) ## [1] &quot;0x7fca991e0000&quot; r_list[[&#39;item100&#39;]] ## [1] 100 2.2.4 Uniqueness R의 named list는 name의 중복을 허용한다. names(new_list) &lt;- rep(&quot;item100&quot;, length(new_list)) head(new_list) ## $item100 ## [1] 1 ## ## $item100 ## [1] 2 ## ## $item100 ## [1] 3 ## ## $item100 ## [1] 4 ## ## $item100 ## [1] 5 ## ## $item100 ## [1] 6 이 경우, 원소의 이름을 사용하여 원소를 찾는 과정이 모호해진다. 원소 이름이 일치하는 첫 번째 원소만을 반환할 것이다. new_list[[&quot;item100&quot;]] ## [1] 1 "],["tuple-list-list.html", "Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 3.1 Tuple vs list in Python 3.2 List in R", " Chapter 3 파이썬의 tuple과 list, 그리고 R의 list 파이썬에 내장된 대표적인 시퀀스(sequence)형 자료 형태로 tuple(튜플, 투플, 터플)과 list(리스트)를 들 수 있다. 두 자료 형태 모두 위치(position)를 사용하여 원소를 읽을 수 있으며, 각 원소가 서로 다른 타입일 수 있다. 예를 들어, 첫 번째 원소는 숫자, 두 번째 원소는 문자열 등으로 구성될 수 있다. Tuple은 흔히 immutable list로 설명되기도 하는데, 일반적으로 그 원소의 값을 modify-in-place로 변경할 수 없기 때문이다. 반면 list는 mutable object로, 기존에 만들어진 list 내에서 원소의 값을 변경하는 것이 가능하다. 보다 자세한 내용은 아래에서 살펴보기로 하자. 기존에 존재하는 원소의 변경 여부 외에, 새로운 원소를 추가할 수 있는지, 즉 기존 n개의 원소를 지닌 시퀀스에 n + 1번째 원소를 추가할 수 있는지에 대한 차이도 존재한다. Tuple의 경우 길이가 고정된 시퀀스로써 새로운 원소를 추가할 수 없지만, list의 경우에는 기존 list에 원소를 추가한다던가 기존 원소를 제거하는 등 시퀀스의 길이를 변경하게 되는 작업을 수행할 수 있다. 하지만 이것이 list가 mutable 객체라고 주장하는 근거가 되기에는 약간 한계가 있는 부분이 있는데, 이는 본문에서 예와 함께 설명하기로 한다. 필자는 이 두 가지 파이썬 자료 형태 중 list가 R의 list와 공통점이 더 많다고 생각한다. 가장 중요한 공통점은 mutable 객체라는 점이다. 즉, 파이썬의 list와 R의 list 모두 modify-in-place를 지원한다. 단, 이 때 R의 경우 single binding을 가정하자. 보다 자세한 내용은 본문에서 다루기로 하자. 3.1 Tuple vs list in Python 파이썬에서 tuple과 list의 차이를 간단한 예를 통해 살펴보자. 3.1.1 Immutable vs mutable 숫자 1부터 10까지를 각 원소로 지니는 길이 10짜리 tuple과 list를 생성해 보자. py_tuple = tuple(x for x in range(1, 11)) py_tuple ## (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) py_list = [x for x in range(1, 11)] py_list ## [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이후, py_tuple의 첫 번째 원소의 값을 변경하려 시도한다면, 오류를 얻게 된다. 이는 tuple이 한 번 생성된 후에는 원소의 값을 변경할 수 없는 immutable 객체이기 때문이다. py_tuple[0] = 0 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;tuple&#39; object does not support item assignment 반면, list의 경우에는 첫 번째 원소(뿐만 아니라 어느 위치의 원소이든)의 값을 변경할 수 있다. 이 때, 내부적으로 새로운 list를 생성하는 것이 아니라, 기존 list의 원소값만 변경하게 된다. 이를 확인하기 위해 원소값 변경 전과 후의 py_list의 메모리 위치를 id(py_list)로 출력해 보자. py_list[0] ## 1 id(py_list) ## 4594223488 py_list[0] = 0 py_list[0] ## 0 id(py_list) ## 4594223488 위 결과와 같이, 원소의 값을 변경하더라도 list 객체의 메모리 위치는 변함이 없는 modify-in-place 방식을 지원한다. 3.1.1.1 Mutable element of tuple 여기에서 tuple의 immutability를 얘기할 때 조심해야 할 부분이 있다. 만약 tuple의 어떤 원소가 list와 같은 mutable 객체라면, 이 mutable 원소의 원소값을 수정할 수 있다. 다음 예에서, tuple a의 두 번째 원소인 list의 첫 번째 원소를 변경할 수 있다. a = (0, [1, 2]) a ## (0, [1, 2]) a[1][0] = 0 a ## (0, [0, 2]) 이는 tuple이 원소의 값 자체가 아니라, 원소의 값이 저장된 위치를 참조하는 reference를 지니기 때문이다. Tuple의 각 원소의 값이 저장된 위치를 변경할 수는 없지만, 그 원소가 mutable 객체라면 그 원소의 값 자체를 변경할 수는 있는 것이다. 이 부분은 본 장에서 핵심적인 부분은 아니기 때문에 여기까지만 설명하기로 하자. 3.1.2 Append items 시퀀스에 새로운 11번째 원소를 추가하고 싶다고 생각해 보자. Tuple의 경우 길이가 정해진 시퀀스이기 때문에 새로운 원소를 이후에 추가할 수가 없다. 만약 꼭 추가해야 한다면, 새로운 tuple을 생성하는 방법 밖에는 없다. 이 경우, 새로운 tuple이 생성되었음을 id() 함수를 통해 확인할 수 있다. id(py_tuple) ## 4594204352 py_tuple = py_tuple + (11, ) py_tuple[10] ## 11 id(py_tuple) ## 4594378432 반면, list의 경우 append()를 사용하여 기존의 list에 원소를 추가할 수 있다. id(py_list) ## 4594223488 py_list.append(11) py_list[10] ## 11 id(py_list) ## 4594223488 이 예에서 py_list의 메모리 주소는 변하지 않았다. 이는 마치 list가 mutable 객체이기 때문인 것으로 보이지만, 필자는 이는 절반만 맞는 설명이라 하겠다. 실제로는, 파이썬은 list를 생성할 때, 이후에 추가될 수 있는 원소를 위한 공간을 미리 어느 정도 남겨둔다. 따라서, 그 남겨둔 공간까지는 원소를 추가하더라도 list에 할당된 메모리 공간이 변하지 않지만, 그 범위를 넘어서는 순간 list에 메모리 공간이 재할당된다. 이 재할당 작업을 너무 자주 수행하지 않기 위해 미리 당장 필요하지 않은 메모리를 확보해 두는 것이다. 다음 예는 list의 메모리 공간이 매 원소 추가 시마다 증가하는 것이 아니라 이따금 한 번에 증가한다는 것을 보여준다. print(sys.getsizeof(py_list)) ## 184 for x in range(12, 31): py_list.append(x) print(f&#39;Number of elements: {len(py_list)}, memory size: {sys.getsizeof(py_list)}&#39;) ## Number of elements: 12, memory size: 184 ## Number of elements: 13, memory size: 184 ## Number of elements: 14, memory size: 184 ## Number of elements: 15, memory size: 184 ## Number of elements: 16, memory size: 184 ## Number of elements: 17, memory size: 256 ## Number of elements: 18, memory size: 256 ## Number of elements: 19, memory size: 256 ## Number of elements: 20, memory size: 256 ## Number of elements: 21, memory size: 256 ## Number of elements: 22, memory size: 256 ## Number of elements: 23, memory size: 256 ## Number of elements: 24, memory size: 256 ## Number of elements: 25, memory size: 256 ## Number of elements: 26, memory size: 336 ## Number of elements: 27, memory size: 336 ## Number of elements: 28, memory size: 336 ## Number of elements: 29, memory size: 336 ## Number of elements: 30, memory size: 336 주의: sys.getsizeof()는 리스트의 각 원소가 참조하는 값에 할당된 메모리를 포함하지 않고, 단지 리스트 자체(각 원소의 주소값을 저장하는 시퀀스)에 할당된 메모리 크기만 나타낸다. 이 예에서 py_list의 메모리 주소는 이전의 메모리 주소와 여전히 동일하다. id(py_list) ## 4594223488 3.2 List in R R에 내장된 대표적인 시퀀스(sequence)형 자료 형태로는 vector와 list가 있는데, 이 중 파이썬의 tuple이나 list와 같이 각 원소의 형태가 다른 시퀀스를 제공하는 R의 시퀀스는 list이다. 위 파이썬의 예와 마찬가지로, 1에서 10까지의 원소값을 지니는 길이 10의 list를 생성해 보자. r_list &lt;- as.list(1:10) r_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 ## ## [[10]] ## [1] 10 3.2.1 Mutable object 이 list가 저장된 메모리 주소를 pryr::address()로 출력해 보자. 또한, 동일한 list 객체가 또 다른 이름으로 참조되고 있지 않은지를 보기 위해 pryr::refs()를 함께 호출해 보자. 이 값이 1인 경우(single binding)에는 modify-in-place 방식이 작동하여 원소값 변경 전/후의 list의 메모리 주소가 변경되지 않지만, 2 이상인 경우에는 copy-on-modify 방식이 작동하여 원소값 변경 시 list가 항상 다른 곳에 복사된 뒤 값이 변경된다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7f9a4ddb9028&quot; &quot;5&quot; 이후, 첫 번째 원소의 값을 변경하려 시도해 보자. 이 때, 만약 앞에서 pryr::refs(r_list)의 값이 1보다 큰 수였다면, 메모리 주소가 변경될 것이다. r_list[[1]] &lt;- 0L r_list[[1]] ## [1] 0 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7f9a4ffee978&quot; &quot;1&quot; 앞의 결과에서 원소값 변경 이후 pryr::refs(r_list)의 값이 1이었다면, 다시금 첫 번째 원소의 값(혹은 어떤 원소의 값이든)을 변경할 때 r_list의 메모리 주소는 동일하게 유지될 것이다. r_list[[1]] &lt;- 1L r_list[[1]] ## [1] 1 c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7f9a4ffee978&quot; &quot;1&quot; 이는 R의 list가 파이썬의 list처럼 modify-in-place를 지원하는 mutable object라는 것을 보여준다. 주의: RStudio IDE 상에서 원소값을 변경할 때는 항상 copy-on-modify 방식이 작동하는데, 이는 RStudio IDE 내의 Environment 창에서 해당 list 객체를 추가로 참조하여 pryr::refs() 값이 항상 1보다 크기 때문이다. 따라서, mutable update는 인터랙티브 개발 환경으로부터 독립된 프로세스에서 작동할 것이다. 3.2.2 Append items 먼저, r_list의 내부 구조를 살펴보기 위해 pryr::inspect()를 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7f9a4ffee978&gt; ## &lt;INTSXP 0x7f9a4daf9b50&gt; ## &lt;INTSXP 0x7f9a59039c80&gt; ## &lt;INTSXP 0x7f9a59039c48&gt; ## &lt;INTSXP 0x7f9a59039c10&gt; ## &lt;INTSXP 0x7f9a59039bd8&gt; ## &lt;INTSXP 0x7f9a59039ba0&gt; ## &lt;INTSXP 0x7f9a59039b68&gt; ## &lt;INTSXP 0x7f9a59039b30&gt; ## &lt;INTSXP 0x7f9a59039af8&gt; ## &lt;INTSXP 0x7f9a59039ac0&gt; 이 결과는 r_list가 VECSXP라는 형태(list)의 C 객체이며, 그 각 원소는 INTSXP라는 형태(integer vector)의 C 객체임을 보여주고, VECSXP 객체와 각 INTSXP 객체가 저장된 메모리 주소를 보여준다. 파이썬의 list에서 새로운 원소를 추가하기 위해 append() method를 사용했던 것과 달리, R의 list에서는 기존 원소를 변경하는 것과 동일한 방법으로 새로운 원소를 추가할 수 있다. r_list[[11]] &lt;- 11L r_list[[11]] ## [1] 11 단, 이 때는 modify-in-place가 아닌 copy-on-modify 방식이 작동한다는 것을 인지하자. 다음에서 메모리 주소가 이전과 변경되었음을 확인할 수 있을 것이다. c(pryr::address(r_list), pryr::refs(r_list)) ## [1] &quot;0x7f9a58f8d0d8&quot; &quot;1&quot; 좀 더 자세히 살펴보기 위해 pryr::inspect()를 다시 호출해 보자. pryr::inspect(r_list) ## &lt;VECSXP 0x7f9a58f8d0d8&gt; ## &lt;INTSXP 0x7f9a4daf9b50&gt; ## &lt;INTSXP 0x7f9a59039c80&gt; ## &lt;INTSXP 0x7f9a59039c48&gt; ## &lt;INTSXP 0x7f9a59039c10&gt; ## &lt;INTSXP 0x7f9a59039bd8&gt; ## &lt;INTSXP 0x7f9a59039ba0&gt; ## &lt;INTSXP 0x7f9a59039b68&gt; ## &lt;INTSXP 0x7f9a59039b30&gt; ## &lt;INTSXP 0x7f9a59039af8&gt; ## &lt;INTSXP 0x7f9a59039ac0&gt; ## &lt;INTSXP 0x7f9a3c826e78&gt; VECSXP 객체의 메모리 주소는 변경된 반면, 하나의 추가된 INTSXP 객체를 제외하면, 기존에 있던 INTSXP 객체의 메모리 주소는 여전히 동일함을 보여준다. 그리고, pryr::address(r_list)가 보여주는 주소값은 VECSXP 객체의 주소값임을 보여준다. 원소를 계속 하나씩 추가하면서, list 메모리 위치가 어떻게 바뀌는지 살펴보자. for (x in 12:30) { r_list[[x]] &lt;- x print( glue::glue( &quot;Number of elements: {length(r_list)}&quot;, &quot;memory address: {pryr::address(r_list)}&quot;, .sep = &quot;, &quot; ) ) } ## Number of elements: 12, memory address: 0x7f9a4d49db78 ## Number of elements: 13, memory address: 0x7f9a58fba568 ## Number of elements: 14, memory address: 0x7f9a58fba2a8 ## Number of elements: 15, memory address: 0x7f9a58fb9e88 ## Number of elements: 16, memory address: 0x7f9a58fb9d28 ## Number of elements: 17, memory address: 0x60000173d500 ## Number of elements: 18, memory address: 0x60000173d440 ## Number of elements: 19, memory address: 0x60000193a080 ## Number of elements: 20, memory address: 0x600001b249a0 ## Number of elements: 21, memory address: 0x600001b249a0 ## Number of elements: 22, memory address: 0x600001d260d0 ## Number of elements: 23, memory address: 0x600001d260d0 ## Number of elements: 24, memory address: 0x600001e24e00 ## Number of elements: 25, memory address: 0x600001e24e00 ## Number of elements: 26, memory address: 0x7f9a5b84e1e0 ## Number of elements: 27, memory address: 0x7f9a5b84e1e0 ## Number of elements: 28, memory address: 0x7f9a5b878030 ## Number of elements: 29, memory address: 0x7f9a5b878030 ## Number of elements: 30, memory address: 0x7f9a5b878150 R list의 경우, 원소 개수가 하나씩 증가할 때마다 메모리 주소가 변경됨을 확인할 수 있을 것이다. 즉, list의 길이가 변경될 때마다 매번 새로 list를 위한 메모리가 재할당되기 때문에 python의 list보다 컴퓨팅 리소스가 좀 더 소모될 것이다. 다만, 앞에서 살펴본 바와 같이 VECSXP 객체의 메모리는 재할당되는 반면, 각 원소값이 저장된 메모리는 그대로 유지되어 참조되므로, 추가적인 컴퓨팅은 제한적이라 하겠다. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
